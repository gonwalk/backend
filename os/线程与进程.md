


写在前面：

　　找工作告一段落，期间经历了很多事情，也思考了许多问题，最后也收获了一些沉甸甸的东西 —— 成长和一些来自阿里、百度、京东(sp)、华为等厂的Offer。好在一切又回到正轨，接下来要好好总结一番才不枉这段经历，遂将此过程中笔者的一些笔试/面试心得、干货发表出来，与众共享之。在此特别要感谢CSDN以及广大朋友的支持，我将坚持记录并分享自己所学、所想、所悟，央请大家不吝赐教，提出您宝贵的意见和建议，以期共同探讨提高。

摘要：

　　本文对面试/笔试过程中经常会被问到的一些关于操作系统的问题进行了梳理和总结，一方面方便自己温故知新，另一方面也希望为找工作的同学们提供一个复习参考。关于这块内容的初步了解和整体掌握，建议大家读一读《操作系统概念》(高教版)一书。
————————————————
版权声明：本文为CSDN博主「书呆子Rico」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/justloveyou_/article/details/78304294
　本文原创作者：书呆子Rico
　　作者博客地址：http://blog.csdn.net/justloveyou_/

1、进程和线程以及它们的区别

进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；

线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；

一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；

进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。
　　
更多关于 操作系统历史及进程/线程由来 的相关介绍请见笔者博文《Java 并发：并发背景》。

2、进程间的通信的几种方式

（1）管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

（2）信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

（3）消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

（4）共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；

（5）信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；

（6）套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

3、线程同步的方式
```
（1）互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

（3）信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量

事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作
```
4、什么是死锁？死锁产生的条件？

1). 死锁的概念

　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。

2). 死锁产生的四个必要条件
```
（1）互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；

（2）占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；

（3）非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放

（4）循环等待：若干进程之间形成一种头尾相接的环形等待资源关系
```

3). 死锁的处理基本策略和常用方法

　　解决死锁的基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等。

　　(1). 死锁预防
　　
　　死锁预防的基本思想是 只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生，具体方法包括：

打破互斥条件：允许进程同时访问某些资源。但是，有些资源是不能被多个进程所共享的，这是由资源本身属性所决定的，因此，这种办法通常并无实用价值。

打破占有并等待条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。

打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。也就是说，但一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。

打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。

　　(2). 死锁避免(的基本思想)
　　
　　死锁避免的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。资源分配图算法和银行家算法是两种经典的死锁避免的算法，其可以确保系统始终处于安全状态。其中，资源分配图算法应用场景为每种资源类型只有一个实例(申请边，分配边，需求边，不形成环才允许分配)，而银行家算法应用于每种资源类型可以有多个实例的场景。

　　(3). 死锁解除

　　死锁解除的常用两种方法为进程终止和资源抢占。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源，此时必须考虑三个问题：

　　(I). 选择一个牺牲品
　　(II). 回滚：回滚到安全状态
　　(III). 饥饿（在代价因素中加上回滚次数，回滚的越多则越不可能继续被作为牺牲品，避免一个进程总是被回滚）

5、进程有哪几种状态？
```
就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；

运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；

阻塞状态： 进程等待某种条件，在条件满足之前无法执行；
```
　　　　　　　　　　　　　　　

6、线程有几种状态？

　　在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：

　　　　　　　　　　

　　线程各状态之间的转换如下：

　　　　　　　　　　　　　

　　更多关于 线程状态及其转化 的相关叙述，请见笔者博文《 Java 并发：Thread 类深度解析》。

7、分页和分段有什么区别（内存管理）？
```
　　段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）

　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。
```
两者的不同点：
```
目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；

大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；

地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；

信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；

内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。
```
8、操作系统中进程调度策略有哪几种？
```
（1）FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU

（2）SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度

（3）优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化

（4）时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。

（5）多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。

（6）多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。
```

9、说一说进程同步有哪几种机制

　　原子操作、信号量机制、自旋锁管程、会合、分布式系统

10、什么是虚拟内存？

1).内存的发展历程

　　没有内存抽象(单进程，除去操作系统所用的内存之外，全部给用户程序使用) —> 有内存抽象（多进程，进程独立的地址空间，交换技术(内存大小不可能容纳下所有并发执行的进程)
）—> 连续内存分配(固定大小分区(多道程序的程度受限)，可变分区(首次适应，最佳适应，最差适应)，碎片) —> 不连续内存分配（分段，分页，段页式，虚拟内存）

2).虚拟内存

　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图5所示。
注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。

　　　　　　　　　　　　　　　　　　　

　　由图5可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。

3). 页面置换算法
```
FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；

LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；

LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；

OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。
```

4). 虚拟内存的应用与优点

　　虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：

在内存中可以保留多个进程，系统并发度提高

解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大

11、颠簸

　　颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。

　　内存颠簸的解决策略包括：

如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；

如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；

否则，还剩下两个办法：终止该进程或增加物理内存容量。

12、局部性原理

(1). 时间上的局部性：最近被访问的页在不久的将来还会被访问；

(2). 空间上的局部性：内存中被访问的页周围的页也很可能被访问。

引用
分段和分页内存管理
BAT面试之操作系统内存详解


原文链接：https://blog.csdn.net/justloveyou_/article/details/78304294





（一）请分别简单说一说进程和线程以及它们的区别。

进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。
线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
一个进程可以有多个线程，多个线程也可以并发执行
如果你对进程或者线程不太熟悉，建议阅读：进程与线程的一个简单解释

（二）线程同步的方式有哪些？


互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。
经两位大大的指正，现已删除临界区。感谢：@真姬酱@安阳

如果你对线程同步的方式不太熟悉，建议阅读：线程同步的几种方式

（三）进程的通信方式有哪些？

主要分为：管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET

管道主要分为：普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe）

管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程
命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信
信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。
消息队列是消息的链表，存放在内核中并由消息队列标识符标识。
信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。
如果你对进程的通信方式不太熟悉，建议阅读： 进程间的几种通信方式

（四）什么是缓冲区溢出？有什么危害？其原因是什么？

缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

危害有以下两点：

程序崩溃，导致拒绝额服务
跳转并且执行一段恶意代码
造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。

如果你想深入了解缓冲区溢出，推荐阅读：缓冲区溢出攻击

（五）什么是死锁？死锁产生的条件？

在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。

死锁产生的四个条件（有一个条件不成立，则不会产生死锁）

互斥条件：一个资源一次只能被一个进程使用
请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系
如果对死锁还不是太熟悉，建议阅读：死锁产生的原因和解锁的方法

（六）进程有哪几种状态？

就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
阻塞状态： 进程等待某种条件，在条件满足之前无法执行
如果你对进程的几种状态以及中间的装换不太了解，建议阅读：进程的三种状态及转换

（七）分页和分段有什么区别？


段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。
段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定
段向用户提供二维地址空间；页向用户提供的是一维地址空间
段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。
如果你对分页和分段还不太了解，建议阅读：分段和分页

（八） 操作系统中进程调度策略有哪几种？

FCFS(先来先服务)，优先级，时间片轮转，多级反馈

如果你想深入的了解这几种调度策略，推荐阅读：几个常用的操作系统进程调度算法

（九）说一说进程同步有哪几种机制。

原子操作、信号量机制、自旋锁管程、会合、分布式系统

如果你想深入的了解这几种机制，推荐阅读： 进程同步的几种机制

（十）说一说死锁的处理基本策略和常用方法。

解决死锁的基本方法如下：

预防死锁、避免死锁、检测死锁、解除死锁

解决四多的常用策略如下：

鸵鸟策略、预防策略、避免策略、检测与解除死锁

如果你对死锁的处理策略不是太熟悉，推荐阅读：产生死锁的原因和必要条件+解决死锁的基本方法

本文参考文献和文章：
「1」操作系统常见面试题总结  http://link.zhihu.com/?target=http%3A//blog.csdn.net/youngchang06hpu/article/details/8009947

「2」 操作系统面试题  http://link.zhihu.com/?target=http%3A//www.cnblogs.com/memewry/archive/2012/08/25/2656966.html

「3」进程间的几种通信方式 http://link.zhihu.com/?target=http%3A//blog.csdn.net/yufaw/article/details/7409596

「4」操作系统各大公司笔试题汇总 http://link.zhihu.com/?target=http%3A//blog.csdn.net/hackbuteer1/article/details/6787354

「5」解决死锁的基本方法 http://link.zhihu.com/?target=http%3A//blog.csdn.net/bxyill/article/details/8237339






常见面试题整理（操作系统）https://blog.csdn.net/gui951753/article/details/79489748

操作系统常见笔试面试题（一）https://blog.csdn.net/xiongluo0628/article/details/81461053