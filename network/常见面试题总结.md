
# 1 OSI七层模型，TCP/IP五层协议的体系结构，以及各层协议
参考：
计算机网络常见面试题
https://www.cnblogs.com/inception6-lxc/p/9152691.html

分享一个很好的博客：http://www.cnblogs.com/maybe2030/p/4781555.html#_label3

## 1.1 模型层次划分
常见的网络层次通常可以划分为TCP/IP 五层模型和OSI七层模型。
```
（1）TCP/IP 四层模型
 网络接口层、网络层、传输层、应用层
（2）TCP/IP 五层模型
 物理层、数据链路层、网络层、传输层、应用层
（3）OSI 七层模型
 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
```
![网络的五层和七层模型划分](https://images2018.cnblogs.com/blog/1118296/201806/1118296-20180612150319215-132711209.jpg  "网络模型层次划分")
## 1.2 OSI七层模型结构
　　1）物理层（Physical Layer）
　　激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。

　　2）数据链路层（Data Link Layer）

　　数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame，帧是数据链路层的传送单位）；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。
数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。

　　有关数据链路层的重要知识点：
```
　　　　1> 数据链路层为网络层提供可靠的数据传输；

　　　　2> 基本数据单位为帧；

　　　　3> 主要的协议：以太网协议；

　　　　4> 两个重要设备名称：网桥和交换机。
```
　　3）网络层（Network Layer）

　　网络层的目的是实现两个主机系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。

　　网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：

　　　　1> 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；

　　　　2> 基本数据单位为IP数据报；

　　　　3> 包含的主要协议：

　　　　IP协议（Internet Protocol，因特网互联协议）;

　　　　ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;

　　　　ARP协议（Address Resolution Protocol，地址解析协议）可看成是跨网络层和链路层的协议;

　　　　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。

　　　　4> 重要的设备：路由器。

　　4）传输层（Transport Layer）

　　第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。

　　传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。作用：为应用进程之间提供端到端的逻辑通信。
　　网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。
　　有关传输层的重点：
　　1> 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；
　　2> 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；
　　3> 重要设备：网关。
注：网络层与传输层的区别（形象解释）
　　5）会话层

　　会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。

　　6）表示层

　　表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。

　　7）应用层

　　是最靠近用户的OSI层，为用户的应用程序提供网络服务的接口。将用户的操作通过应用程序转换成为服务，并匹配一个相应的服务协议发送给传输层。

       注：我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议。

　　会话层、表示层和应用层重点：

　　1> 数据传输基本单位为报文；

　　2> 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（超文本传输协议，Hyper Text Transfer Protocol）。

### 1.2.1 各层对应的协议及物理设备
```
层级            网络协议            对应物理设备
物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器，网关）
数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）
网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP （路由器）
传输层：TCP、UDP、SPX
会话层：NFS、SQL、NETBIOS、RPC
表示层：JPEG、MPEG、ASCII
应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS
```
注：应用层与传输层之间的关系以及端口号起到的作用。
注：TCP/IP协议与Http协议的区别

### 1.2.2 常用协议对应的端口号 
|应用程序|FTP|TFTP|TELNET|SMTP|DNS|HTTP|SSH|MYSQL|
|-|-|-|-|-|-|-|-|-|
|熟知端口|	21,20 |	69|	23|	25|	53|	80|	22|3306|
|传输层协议|TCP|UDP	|TCP|TCP|UDP|TCP|TCP|TCP|

## 1.3 TCP和UDP协议
### 1.3.1 TCP/UDP的区别
TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于将广播和细节控制交给应用的通信传输中，是不可靠传输。

两者的区别大致如下：
```
TCP面向连接；UDP面向非连接，即发送数据前不需要建立链接。
TCP提供可靠的服务（数据传输），UDP无法保证服务的可靠性。
TCP面向字节流，UDP面向报文。
TCP数据传输慢，UDP数据传输快。
TCP提供一种面向连接的、可靠的字节流服务
在一个TCP连接中，仅有两方进行彼此通信，因此广播和多播不能用于TCP
TCP使用校验和，确认和重传机制来保证可靠传输
TCP使用累积确认
TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制
```

### 1.3.2 TCP和UDP的应用场景
```
TCP：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 
在日常生活中，常见使用TCP协议的应用如：浏览器，用的HTTP；FlashFXP，用的FTP；Outlook，用的POP、SMTP；Putty，用的Telnet、SSH；QQ文件传输等。

UDP：当强调传输性能（快）而不是传输的完整性（可靠）时， 要求网络通讯速度能尽量的快。如：QQ语音 QQ视频等。
```
### 1.3.3 TCP对应的协议和UDP对应的协议
```
（1）TCP对应的协议：
FTP：定义了文件传输协议，使用21端口。
Telnet：一种用于远程登陆的协议，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
HTTP：是从Web服务器传输超文本到本地浏览器的传送协议，端口默认80。

（2）UDP对应的协议：
DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在端口69上使用UDP服务。
```
### 1.3.4 为什么 TCP 叫数据流模式？ UDP 叫数据报模式？
```
所谓的“流模式”，是指TCP发送端发送几次数据和接收端接收几次数据是没有必然联系的。比如你通过 TCP连接给另一端发送数据，你只调用了一次 write，发送了100个字节，但是对方可以分10次收完，每次10个字节；你也可以调用10次write，每次10个字节，但是对方可以一次就收完。
原因：这是因为TCP是面向连接的，一个 socket 中收到的数据都是由同一台主机发出，且有序地到达，所以每次读取多少数据都可以。

所谓的“数据报模式”，是指UDP发送端调用了几次 write，接收端必须用相同次数的 read读完。UDP是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文之间是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。
原因：这是因为UDP是无连接的，只要知道接收端的 IP 和端口，任何主机都可以向接收端发送数据。 这时候，如果一次能读取超过一个报文的数据， 则会乱套。
```
## 1.4 TCP中的流量控制和拥塞控制
注：[tcp协议如何保证传输的可靠性](https://blog.csdn.net/jhh_move_on/article/details/45770087)

流量控制主要针对的是端到端传输中，控制流量大小并保证传输可靠性（未收到ack就不滑动）。流量控制往往是指点对点通信量的控制，所要做的是抑制发送端发送数据的速率。

拥塞控制主要是一个全局性过程，涉及到所有主机、路由器、以及与降低网络传输性能有关的所有因素。防止过多的数据注入到网络中。如果有发生丢包则通过拥塞控制减小窗口，确定出合适(慢启动 拥塞避免 快重传 快恢复)的拥塞窗口（增性加乘性减）。
详见[博客链接（重点）](https://www.cnblogs.com/woaiyy/p/3554182.html)以及《计算机网络》（谢希仁）。

## 1.5 TCP的三次握手和四次挥手
在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换TCP窗口大小信息等。
![TCP的三次握手和四次挥手](https://images2018.cnblogs.com/blog/1118296/201806/1118296-20180611104322350-1666660508.jpg "三次握手和四次挥手")

核心思想：让双方都证实对方能发能收。知道对方能收是因为收到对方的因为收到信息之后发的回应(ACK)。
[详解见一个总结的很好的博客](https://blog.csdn.net/qzcsu/article/details/72861891)

### 1.5.1 TCP连接的建立（三次握手）
[三次握手动图](https://img-blog.csdn.net/20170607205709367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast "三次连接的建立过程")

最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。
```
1.TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
2.TCP客户端进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
3.TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
4.TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
5.当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。
```
![TCP连接建立后客户端和服务端的状态](https://img-blog.csdn.net/20170605110405666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 1.5.2 为什么TCP客户端最后还要发送一次确认呢？
一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。
```
如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。
```

### 1.5.3 TCP连接的释放（四次挥手）

![四次挥手动图](https://img-blog.csdn.net/20170607205756255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。
```
1.客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2.服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3.客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4.服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5.客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6.服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
```
![四次挥手后客户端与服务端状态变化](https://img-blog.csdn.net/20170606084851272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


### 1.5.4 为什么客户端最后还要等待2MSL？
MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。
```
第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
```

### 1.5.5 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
```
建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
```



原文链接：https://blog.csdn.net/qzcsu/article/details/72861891


参考：
[TCP的三次握手与四次挥手（详解+动图）](https://blog.csdn.net/qzcsu/article/details/72861891)

常见端口及对应的服务
![常见端口及对应服务](https://images2018.cnblogs.com/blog/1118296/201806/1118296-20180611104155206-1495915191.png "端口及对应服务")

[端口详解链接（百度百科）](https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3/103505?fr=aladdin)

## 1.6 端口
注意区别硬件端口。

软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。
端口号只具有本地意义，它只为标志计算机应用层中的各个进程在和运输层交互时的层间接口，在互联网不同计算机中，相同的端口号是没有关联的。
两个计算机的进程相互通信，不仅需要知道对方的IP地址（为了找到对方计算机），还要知道对方的端口号（为了找到对方计算机中的应用进程）
两大类：1.服务器端使用的端口号（常用熟知）2.客户端使用的端口号（短暂）。
 

## 1.7 TCP如何实现可靠性传输
确认机制、重传机制、滑动窗口。

 

## 1.8 UDP如何实现可靠性传输
传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

实现确认机制、重传机制、窗口确认机制。

如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：

发送：包的分片、包确认、包的重发

接收：包的调序、包的序号确认

注： 
1）给数据包编号，按照包的顺序接收并存储； 
2）接收端接收到数据包后发送确认信息给发送端，发送端接收确认数据以后再继续发送下一个包，如果接收端收到的数据包的编号不是期望的编号，则要求发送端重新发送。

目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。

在浏览器中输入www.baidu.com后执行的全部过程
一个总结的比较好的博客：

1、应用层：客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。

DNS解析过程
![DNS解析过程](https://images2015.cnblogs.com/blog/949433/201610/949433-20161003112743457-1580560271.png "DNS解析示意图")

# 2 HTTP（超文本传输协议）
HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。

HTTP是一个基于TCP/IP通信协议来传递数据，默认端口号为80。

## HTTP工作原理

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。

　　HTTP 请求/响应的步骤

　　1、客户端连接到Web服务器

　　　　一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。

　　2、发送HTTP请求

　　　　通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

　　3、服务器接受请求并返回HTTP响应

　　　　Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

　　4、释放连接TCP连接

　　　　若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

　　5、客户端浏览器解析HTML内容

　　　　客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

## HTTP消息结构

HTTP是基于客户端/服务端（C/S）的架构模型

　　客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，请求报文的一般格式



HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。



## http常见状态码

状态码告知从服务器端返回的请求结果。

 2开头状态码
    2xx (成功)表示成功处理了请求的状态代码
200 (成功) 服务器已成功处理了请求。 通常。
3开头状态码
    3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
4开头状态码
    4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理
1:400 (错误请求) 服务器不理解请求的语法。
 
2:403 (禁止) 服务器拒绝请求。

3:404 (未找到) 服务器找不到请求的网页。

5开头状态码
   5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错
500 (服务器内部错误) 服务器遇到错误，无法完成请求。

501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。

502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。

503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。

504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。

505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。

重点：200,304,403，404,500
HTTP与HTTPS区别
 

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

 

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

 

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

 

4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

HTTPS工作原理

更容易理解的一个链接

 

HTTP1.0和HTTP1.1的区别
HTTP长连接与短链接
 

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

 

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

 

Connection:keep-alive
 

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

 

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。


## HTTP请求与响应
![HTTP请求与响应](https://images2015.cnblogs.com/blog/949433/201610/949433-20161003112956551-47764667.png "HTTP请求与响应过程")

  2、运输层：在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层（网络层）的IP地址查找目的端。

  3、网络层：客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。

![网络层间IP数据报传输过程](https://images2015.cnblogs.com/blog/949433/201610/949433-20161003113244364-1528707344.png "IP数据报在网络层上的传输过程")

  4、链路层：客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。
![ARP请求与响应](https://images2015.cnblogs.com/blog/949433/201610/949433-20161003113343739-692523291.png)
    

# 3 交换机、路由器的概念，并知道各自的用途
        交换机
在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。
交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。
　　路由器
路由器（Router）是一种计算机网络设备，提供了路由与转发两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转送。路由工作在OSI模型的第三层——即网络层，例如IP协议。
路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。




 

DNS域名系统，简单描述其工作原理。
链接

当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。

路由选择协议
路由选择协议的任务就是要确定数据报在源与目的地之间采用的路径。

路由选择协议分为：静态的和动态的。Internet中使用的是动态路由选择协议，在Internet的概念中，将整个互联网划分为许多个小的自治系统（AS）。AS的最主要的特征：一个AS对其他AS表现出的是一个单一 和一致的路由选择策略。

由于AS的存在，路由选择协议又分为两种：

内部网关协议（IGP）：即在一个AS内部使用的路由选择协议，而这与互联网中其他AS选用什么路由协议无关。比如：RIP，OSPF
外部网关协议（EGP）：若源主机和目的主机不再同一个AS中，就需要使用一种协议将路由选择信息传递到另一个AS中，这就是EGP。比如：BGP。
重传机制
网络万一阻塞了呢？发出去的请求包在规定时间内没有收到ACK，不管是请求包丢失，还是ACK包丢失，还是网络延迟，总之，这里都是需要有个重传机制的。TCP的重传机制有两种：超时重传和快速重传。

超时重传
说白了就是在请求包发出去的时候，开启一个计时器，当计时器达到时间之后，没有收到ACK，则就进行重发请求的操作，一直重发直到达到重发上限次数或者收到ACK。

快速重传
还有一种机制就是快速重传，当接收方收到的数据包是不正常的序列号，那么接收方会重复把应该收到的那一条ACK重复发送，这个时候，如果发送方收到连续3条的同一个序列号的ACK，那么就会启动快速重传机制，把这个ACK对应的发送包重新发送一次。具体可以参考：



 

TCP/IP通信过程（以发送电子邮件为例）
socket通信原理
网络编程中的基本概念
 

TCP粘包问题
1 什么是粘包现象
　　TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

2 为什么出现粘包现象
　　（1）发送方原因

　　我们知道，TCP默认会使用Nagle算法。而Nagle算法主要做两件事：1）只有上一个分组得到确认，才会发送下一个分组；2）收集多个小分组，在一个确认到来时一起发送。

　　所以，正是Nagle算法造成了发送方有可能造成粘包现象。

　　（2）接收方原因

　　TCP接收到分组时，并不会立刻送至应用层处理，或者说，应用层并不一定会立即处理；实际上，TCP将收到的分组保存至接收缓存里，然后应用程序主动从缓存里读收到的分组。这样一         来，如果TCP接收分组的速度大于应用程序读分组的速度，多个包就会被存至缓存，应用程序读时，就会读到多个首尾相接粘到一起的包。

3 什么时候需要处理粘包现象
　　（1）如果发送方发送的多个分组本来就是同一个数据的不同部分，比如一个很大的文件被分成多个分组发送，这时，当然不需要处理粘包的现象；

　　（2）但如果多个分组本毫不相干，甚至是并列的关系，我们就一定要处理粘包问题了。

4 如何处理粘包现象
　　（1）发送方

　　对于发送方造成的粘包现象，我们可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭Nagle算法。

　　（2）接收方

　　遗憾的是TCP并没有处理接收方粘包现象的机制，我们只能在应用层进行处理。

　　（3）应用层处理

　　应用层的处理简单易行！并且不仅可以解决接收方造成的粘包问题，还能解决发送方造成的粘包问题。

　　解决方法就是循环处理：应用程序在处理从缓存读来的分组时，读完一条数据时，就应该循环读下一条数据，直到所有的数据都被处理；但是如何判断每条数据的长度呢？

　　两种途径：

　　　　1）格式化数据：每条数据有固定的格式（开始符、结束符），这种方法简单易行，但选择开始符和结束符的时候一定要注意每条数据的内部一定不能出现开始符或结束符；

　　　　2）发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4字节是数据的长度（一个int来储存数据长度大小），应用层处理时可以根据长度来判断每条数据的开始和结束。

详细还可以参考此博客：链接

TCP协议中的三次握手四次挥手以及11种状态转换
链接地址

注：

TIME_WAIT状态的作用：
1、可靠地实现TCP的连接终止。
在终止TCP连接时有4个报文需要交换，其中最后一个ACK报文是由客户端发往服务器。假设这个ACK报文在网络中被丢弃了，那么服务器端收不到这个确认ACK，服务器端会向客户端再次发送FIN。这就是为什么TIME_WAIT状态持续2倍的最长报文段生存时间：1MSL时间留给最后的ACK确认报文段到达服务器端，1MSL时间留给服务器端再次发送的FIN。
2、确保老的重复的报文段在网络中过期失效，这样建立新的连接时将不再接受它们。
TCP协议采用的是出错重传，也就是会生成重复的报文，并且根据路由器的选择，这些重复的报文可能在连接终止后才到达，如果客户端/服务器端收到这个老的报文会把它误认为一个同一连接的新的报文，然后对这个报文进行处理，这样就会出现错误。从状态转换图我们可以看到从TIME_WAIT到连接终止，中间有2MSL，这个时间足以让老的重复的报文段过期失效。