# 1.事务

参考：
数据库四大特性和事务隔离级别：https://www.cnblogs.com/Andya/p/7426436.html


## 1.1 什么是数据库事务

数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。
事务处理可以确保 除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。

## 1.2 事务的特性及其含义

事务有四个特性，分别是原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)，简称ACID。

事务四大特性及解释
``` 
原子性：事务是以原子为工作单元，对于数据修改，要么全都执行，要么全都不执行。
  
一致性：事务执行前后，数据结果一致。

隔离性：事务所作的修改与其它并发事务所作的修改隔离（即在所有操作全部执行完以前，其它会话不能看到过程）。

持久性：一旦事务提交，它对数据的改变就是永久的。
```

## 1.3 事务隔离级别

隔离级别一共有四种：读未提交、读已提交、可重复读、串行化。这四种隔离级别分别可以解决的不同的问题

### 1.3.1 不使用隔离级别可能会出现的几种问题

当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。

在介绍数据库提供的各种隔离级别之前，如果不考虑事务的隔离性，会发生的几种问题有：丢失修改、脏读、不可重复读、幻读。
```
（1）丢失修改

A和B两个事务同时修改同一个数据，A修改的提交在B提交之后，导致B好像没有修改，丢失修改。

（2）脏读（简单理解为一个事务读取到其他事务的未提交数据）

B事务修改了一个数据并未提交，A事物读取了这个数据（修改后），然后B事务回滚了，最后A又读取了一次（修改前），两次读取的数据不一致，称为脏读。

（3）不可重复读（事务的修改影响其他事务的读取）

A事务读取了一个数据后，B事务修改了这个数据，A事务又读取了这个数据，两次读取的数据也不一致，称为不可重复读。

（4）幻读（不同事务更新之间的影响）

A事务更新了某个字段（范围是整个数据表的）（以id=1为条件的），B事务又插入了一条新的记录，导致A事务认为自己没有完全更新过来，就像出现幻觉一样。
```

### 1.3.2 事务的隔离级别

Mysql的默认隔离级别是Repeatable read。
```
（1）读未提交(Read uncommitted)：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。读写均不使用锁，数据的一致性最差，也会出现许多逻辑错误。

（2）读已提交(Read committed)：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。使用写锁，但是读会出现不一致，不可重复读。

（3）可重复读(Repeatable read)，就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。使用读锁和写锁，解决不可重复读的问题，但会有幻读问题。

（4）串行化(Serializable)，是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。，使用事务串行化调度，避免出现因为插入数据没法加锁导致的不一致的情况。

串行化是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争
```


### 1.3.3 不同的事务隔离级别分别解决的问题

（1）丢失修改问题，一般使用加锁来解决，串行化不仅可以解决该问题，而且可以解决上面出现的所有问题。

（2）脏读问题，是因为A事务读取B事务未提交的数据，设置读已提交隔离级别可以解决这个问题，但不可解决不可重复读和幻读的问题。

（3）不可能重复读问题，是因为B事物的修改影响了A事务读取数据，设置可重复读隔离级别，使得B事务修改数据和A事务读取数据互不影响，隔离开来，从而解决这个问题，同时解决脏读问题。

（4）幻读问题，是因为A事务更新完数据后，B事务又插入了新的数据，设置串行化隔离级别可解决，并且这种隔离级别可以解决上面所有的问题。除了串行化，多版本并发控制（MVCC，Multiversion Concurrency Control）机制也可以解决该问题。

总结，对于不加事务时可能出现的情况，可以简单地理解为：
```
脏读：事务B读取事务A还没有提交的数据

不可重复读：两次事务读的数据不一致

幻读:事务A修改了数据，事务B也修改了数据，这时在事务A看来，明明修改了数据，咋不一样
```

事务隔离级别及解决的问题

|隔离级别|脏读|不可重复读|幻读|
|-|-|-| - |
|读未提交|出现|出现|出现|
|读已提交|不出现|出现|出现|
|可重复读|不出现|不出现|出现|
|串行化|不出现|不出现|不出现|

## 1.4 事务的传播属性
参考：
数据库事务的总结：https://www.cnblogs.com/yebingluo/p/10143380.html

spring通过配置事务的传播属性来严格控制事务行为。比如  在一个配置了事务的方法中调用了另一个方法，则另一个方法应该怎么运行，是新开启一个事务，还是和调用方法是一个事务，还是 不开启事务？一共有七种传播属性。
```
PROPAGATION_REQUIRED（需要） 表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务。

PROPAGATION_SUPPORTS （支持）表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行，如果不存在事务就不在事务中执行。

PROPAGATION_MANDATORY （强制必须）表示该当前方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常。

PROPAGATION_REQUIRED_NEW（要求新事物） 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager。

PROPAGATION_NOT_SUPPORTED（不支持新事物） 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager。

PROPAGATION_NEVER （从不）表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常。

PROPAGATION_NESTED（嵌套）（spring） 表示如果当前方法已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。
```
## 1.5 分布式事务
分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。当数据库的数据越来越大，数据库无法承受起压力，就会开始分库分表，分库分表后不同的库就会分布在不同的服务器上，明显的就会出现数据一致性问题。或者同一个事务中要调用的不同系统的不同的库，也要保证要不全都成功，要不全部回滚。

如何解决分布式事务数据一致性问题，下面分别总结几种方案。

（1）两阶段提交 

       事务协调器首先会将prepare消息写入日志中，然后向AB数据库发出prepare消息，操作完成后先不提交，而是返回yes，如果事务协调器收到的返回都是yes，则全部执行提交。如果有一个不是yes，则向所有的执行器发送abort（退出、回滚）操作。

       这种两阶段提交的方式能够保证数据一致性。但是牺牲了一定的可用性。

       优点： 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）

       缺点： 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布式系统跨接口调用，目前 .NET界还没有实现方案。

    （2）三段式提交协议

       在二阶段提交的基础上，在提交的时候，先发出precommit（预提交），当所有的执行器返回yes，再最终发出提交操作申请。否则向所有的执行器发送abort（退出）请求。

       优点：降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。

       缺点：在去除阻塞的情况下引入了新的问题，那就是参与者接收到了PreCommit消息，然后网络出现问题，参与者和协调者无法通信，这种情况下，参与者依然会执行事务的提交。

     （3）补偿事务（TCC）

        简单举个例子说明，比如一个借钱产品，你发起借钱时，你的可借额度会被冻结，借钱成功，扣减额度并解冻。借钱失败则解冻额度，如果可借额度发生变化，还需要回滚额度。

        优点： 跟2PC（二段式事务）比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些

        缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC定义及处理。

     （4）本地消息表

       消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。

       消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

       优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中有现成的解决方案。

       缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

    （5）基于可靠消息服务的分布式事务

        有一些第三方的MQ是支持事务消息的，比如RocketMQ

        - 在系统A处理任务A前，首先向消息中间件发送一条消息
        - 消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。
        - 消息中间件持久化成功后，便向系统A返回一个确认应答；
        - 系统A收到确认应答后，则可以开始处理任务A；
        - 任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。
        - 但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成。
        - 消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；
        - 当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。

原文：https://blog.csdn.net/u010425776/article/details/79516298

参考：https://blog.csdn.net/u012092620/article/details/80222007



# 2 锁
参考：数据库中的锁https://www.cnblogs.com/kexinxin/p/11620345.html


## 2.1 锁分类
```
按锁的粒度划分：表级锁、行级锁、页级锁

按锁级别划分：共享锁、排它锁、意向锁

按加锁方式划分：自动锁、显示锁

按使用方式划分：乐观锁、悲观锁
```

## 2.1.1 行级锁、表级锁和页级锁
MySQL中的行级锁、表级锁和页级锁分别是什么？
```
（1）行级锁：行级锁分为共享锁和排他锁。行级锁是MySQL中锁定粒度最细的锁。InnoDB引擎支持行级锁和表级锁，只有在通过索引条件检索数据的时候，才使用行级锁，否则使用表级锁。行级锁开销大，加锁慢，锁定粒度最小，发生锁冲突的概率最低，并发度最高。

（2）表级锁：表级锁分为表共享锁和表独占锁。表级锁开销小，加锁快，锁定粒度大，发生锁冲突最高，并发度最低。

（3）页级锁：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多；行级锁冲突少，但速度慢。所以取了折中的页级，一次锁定相邻的一组记录。BDB支持页级锁。开销和加锁时间界于表锁和行锁之间；会出现死锁现象。锁定粒度界于表锁和行锁之间，并发度一般。
```

## 2.1.2 排它锁、共享锁、意向锁
```
（1）排它锁（exclusive lock）

排他锁又叫写锁，如果事务T对A加上排它锁，则其他事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据

（2）共享锁（share lock）

共享锁又叫读锁，如果事务T对A加上共享锁，则其他事务只能对A再加共享锁，不能加其他锁。共享锁的事务只能读数据，不能写数据。

（3）意向锁
其实有排它锁和共享锁就足够了为什么还需要有意向锁，这里举一个比较形象的例子：
在mysql中使用表锁和读锁锁表时，会阻塞其他事务修改表数据。使用写锁锁表时，会阻塞其他事务读和写。

Innodb引擎又支持行锁，行锁分为共享锁，一个事务对一行的共享只能读。排它锁，一个事务对一行的数据既可以读又可以写。
这两种类型的锁存在一个共存的问题，考虑这个例子：事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。

数据库要怎么判断这个冲突呢？

step1：判断表是否已被其他事务用表锁锁表；
step2：判断表中的每一行是否已被行锁锁住。
注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。于是就有了意向锁。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。

在意向锁存在的情况下，上面的判断可以改成

step1：不变，判断表是否已被其他事务用表锁锁表；
step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。

注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要程序员使用代码来申请。
```

### 2.1.3 InnoDB的锁定模式

InnoDB的锁定模式实际上可以分为四种：共享锁（S）、排它锁（X）、意向共享锁（IS）和意向排它锁（IX），我们可以通过以下表来总结上面四种锁的共存逻辑关系：
||共享锁(S)|排他锁(X)|意向共享锁(IS)|意向排他锁(IX)|
|-|-|-|-|-|
|共享锁(S)|兼容|冲突|兼容|冲突|
|排他锁(X)|冲突|冲突|冲突|冲突|
|意向共享锁(IS)|兼容|冲突|兼容|冲突|
|意向排他(IX)|冲突|冲突|兼容|兼容|


如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。

意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁(X)；对于普通SELECT语句，InnoDB不会加任何锁。

### 2.1.4 间隙锁（Next-Key锁）

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做"间隙（GAP)"，InnoDB也会对这个"间隙"加锁，这种锁机制就是所谓的间隙锁 （Next-Key锁）。 
举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：

Select * from emp where empid > 100 for update;

是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的"间隙"加锁。

InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求；另外一方面，是为了满足其恢复和复制的需要。
对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读。

很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！


### 2.1.5 有哪些锁,select时怎么加排它锁
锁	概念
乐观锁	自己实现，通过版本号
悲观锁	共享锁，多个事务，只能读不能写，加 lock in share mode
排它锁	一个事务，只能写，for update
行锁	作用于数据行
表锁	作于用表

## 2.2 死锁怎么解决
找到进程号，kill 进程

# 3 存储引擎
## 3.1 存储引擎分类
常见的数据库存储引擎有MyISAM、InnoDB、Memory、Maria、Federated、Archive、NDB等。

## 3.2 MyIsAM和InnoDB两种存储引擎区别及适用场景

Mysql中的myisam与innodb的区别，至少五点
```
InnoDB支持事务，而MyISAM不支持事务；
InnoDB支持行级锁，而MyISAM支持表级锁；
InnoDB支持MVCC（多版本并发控制Multi-Version Concurrency Control, MVCC），而MyISAM不支持；
InnoDB支持外键，而MyISAM不支持；
InnoDB不支持全文索引，而MyISAM支持；
InnoDB不能通过直接拷贝表文件的方法拷贝表到另外一台机器， MyISAM支持；
InnoDB表支持多种行格式，MyISAM不支持；
InnoDB是索引组织表，MyISAM是堆表；
```

简单总结来说，两者区别如下：
```
（1）MYISAM：不支持外键，表锁；插入数据时，锁定整个表；查表总行数时，不需要全表扫描。
（2）InnoDB：支持外键、事务、行锁、多版本并发控制；查表总行数时，全表扫描。
```

### 3.2.1 InnoDB引擎的4大特性
```
（1）插入缓冲(insert buffer)；
（2）二次写(double write)；
（3）自适应哈希索引(ahi)；
（4）预读(read ahead)。
```

InnoDB引擎的行锁是基于什么上实现的？答：基于索引。

MyIsAM与InnoDB select count(*)哪个更快，为什么？
答：MyIsAM更快，因为MyIsAM内部维护了一个计数器，可以直接调取。

### 3.2.2 数据表类型有哪些
答：MyIsAM、InnoDB、HEAP、ISAM、MERGE、DBD以及Gemeni(一般只知道前两者即可)

# 4 索引

## 4.1 索引分类

1.索引分类，索引失效条件
索引类型	概念
```
普通索引	最基本的索引，没有任何限制
主键索引	它是一种特殊的唯一索引，不允许有空值。
唯一索引	与"普通索引"类似，不同的是：索引列的值必须唯一，但允许有空值，允许有多个。
全文索引	针对较大的数据，生成全文索引很耗时，耗空间。
组合索引	为了更多的提高mysql效率可建立组合索引，遵循“最左前缀”原则
```

失效条件
条件是or，如果还想让or条件生效，给or每个字段加个索引
like查询，以%开发

### 4.1.2 聚集索引和非聚集索引
两者区别如下：
```
（1）聚集索引：数据按索引顺序存储，结点存储真实的物理数据；
（2）非聚集索引：存储指向真正数据行的指针
```

2.普通索引、唯一索引、主键索引、全文索引区别
【mysql】主键、普通索引、唯一索引和全文索引的比较：https://www.cnblogs.com/xuzhengzong/p/7680464.html

```
（1）普通索引

这是最基本的索引类型，而且它没有唯一性之类的限制。

创建索引，例如CREATE INDEX <索引的名字> ON tablename (列的列表);
修改表，例如ALTER TABLE tablename ADD INDEX [索引的名字] (列的列表);
创建表的时候指定索引，例如CREATE TABLE tablename ( [...], INDEX [索引的名字] (列的列表) );


（2）唯一性索引

这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一。

（3）MYSQL主键

MYSQL主键是一种唯一性索引，但它必须指定为“PRIMARY KEY”。

例如“CREATE TABLE tablename ( [...], PRIMARY KEY (列的列表) ); ”。但是，我们也可以通过修改表的方式加入主键，例如“ALTER TABLE tablename ADD PRIMARY KEY (列的列表); ”。每个表只能有一个主键。

（4）全文索引 （适合在进行模糊查询的时候使用）

MySQL从3.23.23版开始支持全文索引和全文检索。在MySQL中，全文索引的索引类型为FULLTEXT。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。它可以通过CREATE TABLE命令创建，也可以通过ALTER TABLE或CREATE INDEX命令创建。对于大规模的数据集，通过ALTER TABLE（或者CREATE INDEX）命令创建全文索引要比把记录插入带有全文索引的空表更快。
```

总结一下，就是：
```
PRIMARY 主键, 是唯一的且不能为空。

INDEX 普通的索引

UNIQUE 唯一索引，可以为空，允许有多个（即一张表可以创建多个唯一索引）。

FULLTEXT 是全文索引，用于在一篇文章中，检索文本信息的。
```

### 4.1.1 B+索引和Hash索引
两者区别：
```
（1）B+树索引：数据有序，适用于范围查询。
（2）Hash索引，等值（使用=的查询）查询效率高，不能排序，不能进行范围查询。
```



### 4.1.3 InnoDB索引和MyISAM索引
两者区别如下：
（1）主索引的区别，InnoDB的数据文件本身就是索引文件；而MyISAM的索引和数据是分开的。
（2）辅助索引的区别：InnoDB的辅助索引data域存储相应记录主

### 主键索引与唯一索引
主键和唯一索引的区别：https://blog.csdn.net/DreamWeaver_zhou/article/details/81661118

1.主键和唯一索引都要求值唯一，但是它们还是有区别的：

①.主键是一种约束，唯一索引是一种索引；
②.一张表只能有一个主键，但可以创建多个唯一索引；
③.主键创建后一定包含一个唯一索引，唯一索引并一定是主键；
④.主键不能为null，唯一索引可以为null；
⑤.主键可以作为外键，唯一索引不行；

2.主键约束比唯一索引约束严格，当没有设定主键时，非空唯一索引自动成为主键。对于主键和唯一索引的一些区别主要如下：

1.主键不允许空值，唯一索引允许空值
2.主键只允许一个，唯一索引允许多个
3.主键产生唯一的聚集索引，唯一索引产生唯一的非聚集索引

注：聚集索引确定表中数据的物理顺序，所以主键是唯一的（聚集就是整理数据的意思）


## 4.2 索引优缺点

对数据进行频繁查询时（对这些频繁查询的字段）建立索引可以提高查询效率，如果要频繁更改数据不建议使用索引。

### 4.2.1 什么情况下建立索引

在什么情况下建立索引呢？一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL只对<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。例如：
SELECT t.Name 
FROM mytable t LEFT JOIN mytable m   
ON t.Name=m.username WHERE m.age=20 AND m.city='郑州' 
此时就需要对city和age建立索引，由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。

刚才提到只有某些时候的LIKE才需建立索引。因为在以通配符%和_开头作查询时，MySQL不会使用索引。例如下句会使用索引：
SELECT * FROM mytable WHERE username like'admin%' 
而下句就不会使用：
SELECT * FROM mytable WHEREt Name like'%admin' 
因此，在使用LIKE时应注意以上的区别。

### 4.2.2 索引优缺点

数据库创建索引有什么优点和缺点：https://zhidao.baidu.com/question/53672881.html

#### 4.2.2.1 数据库中创建索引的优点

索引最大的好处是提高查询速度。
```
1、创建唯一性索引，保证数据库表中每一行数据的唯一性。

2、加快数据的检索速度，这也是创建索引的最主要的原因。

3、减少磁盘IO（像字典一样可以直接定位）。

4、通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

5、加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
```

#### 4.2.2.2 数据库中创建索引的缺点

缺点是更新（插入、删除等）数据时效率低，因为要同时更新索引。

```
1、创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

2、索引需要占用物理空间，特别是聚集索引，需要较大的空间。

3、当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度
```




## 4.3 索引底层实现
索引的底层实现（B+树，为何不采用红黑树或B树）重点

### 4.3.1 B树、B+树、红黑树三者区别
```
红黑树，在增加、删除节点时，红黑树会进行频繁的调整，以保证满足红黑树的性质，但是这样造成时间浪费。
B树也就是B-树，其查询性能不稳定，查询结果不一致，每个结点保存指向真实数据的指针，相比B+树每一层存储的元素更多，这样就显得B树比B+树更高一点。
B+树相比较于另外两种树，显得更矮更宽，查询层次更浅，查询效率更高。
```
### 4.3.2 数据库中为什么使用B+树作为索引

为什么使用B+Tree
```
索引查找过程中会产生磁盘I/O消耗，主要看IO次数，和磁盘存取原理有关。
B-Tree（即B树）检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。
局部性原理与磁盘预读
```

### 4.3.3 B+树的实现
一个m阶的B+树具有如下几个特征：
```
（1）有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
（2）所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
（3）所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素
```

## 4.4 树
 
### 4.4.1 红黑树特点
红黑树的特性:
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙（叶子）节点的所有路径上包含相同数目的黑节点。[这里指到叶子节点的路径]


# 5 SQL优化

11.Sql的优化
1.sql尽量使用索引，而且查询要走索引

2.对sql语句优化

子查询变成left join
limit 分布优化，先利用ID定位，再分页
or条件优化，多个or条件可以用union all对结果进行合并（union all结果可能重复）
不必要的排序
where代替having,having 检索完所有记录，才进行过滤
避免嵌套查询
对多个字段进行等值查询时，联合索引


12.索引最左前缀问题
如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了







14.数据库的主从复制
复制方式	操作
异步复制	默认异步复制，容易造成主库数据和从库不一致,一个数据库为Master,一个数据库为slave,通过Binlog日志,slave两个线程，一个线程去读master binlog日志，写到自己的中继日志一个线程解析日志，执行sql,master启动一个线程,给slave传递binlog日志
半同步复制	只有把master发送的binlog日志写到slave的中继日志，这时主库,才返回操作完成的反馈，性能有一定降低
并行操作	slave 多个线程去请求binlog日志
15.long_query怎么解决
设置参数，开启慢日志功能，得到耗时超过一定时间的sql
1
16.varchar和char的使用场景
类型	使用场景
varchar	字符长度经常变的
char	用字符长度固定的
17.数据库连接池的作用
维护一定数量的连接，减少创建连接的时间
更快的响应时间
统一的管理


19.分库分表，主从复制，读写分离
读写分离，读从库，写主库
spring配置两个数据库，通过AOP（面向切面编程），在写或读方法前面进行判断得到动态切换数据源。
1
2
20.数据库三范式
级别	概念
1NF	属性不可分
2NF	非主键属性，完全依赖于主键属性
3NF	非主键属性无传递依赖
21.关系型数据库和非关系型数据库区别
关系型数据库

优点

1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；

2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；
3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；
4、支持SQL，可用于复杂的查询。
5.支持事务

缺点
1、为了维护一致性所付出的巨大代价就是其读写性能比较差；
2、固定的表结构；
3、不支持高并发读写需求；
4、不支持海量数据的高效率读写


非关系型数据库

1、使用键值对存储数据；
2、分布式；
优点
无需经过sql层的解析，读写性能很高
基于键值对，数据没有耦合性，容易扩展
存储数据的格式：nosql的存储格式是key,value形式
缺点
不提供sql支持


22.数据库中join的inner join, outer join, cross join
1.以A，B两张表为例
A left join B
选出A的所有记录，B表中没有的以null 代替
right join 同理

2.inner join
A,B的所有记录都选出，没有的记录以null代替

3.cross join (笛卡尔积)
A中的每一条记录和B中的每一条记录生成一条记录
例如A中有4条，B中有4条，cross join 就有16条记录



25.最左匹配原则
最左匹配原则是针对索引的
举例来说：两个字段（name,age）建立联合索引，如果where age=12这样的话，是没有利用到索引的，
这里我们可以简单的理解为先是对name字段的值排序，然后对age的数据排序，如果直接查age的话，这时就没有利用到索引了，
查询条件where name=‘xxx’ and age=xx 这时的话，就利用到索引了，再来思考下where age=xx and name=’xxx‘ 这个sql会利用索引吗，
按照正常的原则来讲是不会利用到的，但是优化器会进行优化，把位置交换下。这个sql也能利用到索引了



数据库三大范式第一范式：数据库表中的字段都是单一属性的，不可再分(保持数据的原子性)；第二范式：第二范式必须符合第一范式，非主属性必须完全依赖于主键。第三范式：在满足第二范式的基础上，在实体中不存在其他实体中的非主键属性，传递函数依赖于主键属性，确保数据表中的每一列数据都和主键直接相关，而不能间接相关(表中字段[非主键]不存在对主键的传递依赖)
说一说你能想到的sql语句优化，至少五种避免select *，将需要查找的字段列出来；使用连接（join）来代替子查询；拆分大的delete或insert语句；使用limit对查询结果的记录进行限定；用 exists 代替 in 是一个好的选择；用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤；不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引尽量避免在where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描；尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描；尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描；
说一说你能想到的表结构优化，至少五种永远为每张表设置一个ID (所有建表的时候不设置主键的程序猿都应该被辞退)；选择正确的存储引擎 ;使用可存下数据的最小的数据类型，整型 < date,time < char,varchar < blob；使用简单的数据类型，整型比字符处理开销更小，因为字符串的比较更复杂。如，int类型存储时间类型，bigint类型转ip函数；使用合理的字段属性长度，固定长度的表会更快。使用enum、char而不是varchar；尽可能使用not null定义字段(给空字段设置默认值)；尽量少用text;给频繁使用和查询的字段建立合适的索引；

MySql面试题及答案大全https://baijiahao.baidu.com/s?id=1626325768515979989&wfr=spider&for=pc

说几个mysql中你常用的函数答：sum、count 、avg、min、max
说几个你除了增删改查之外在mysql中常用的命令答：Explain、describe、show、truncate
说几个除了增删改查之外常用的关键字答：distinct、limit、offset、order by、union、union all、between、group by；
union、union all的区别对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录；对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回；从效率上说，UNION ALL 要比UNION快很多
varchar(100)和varchar(200)的区别答：varchar(100)最多存放100个字符，varchar(200)最多存放200个字符，varchar(100)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)
varchar(20)和int(20)中的20含义一样吗答：不一样，前者表示最多存放20个字符，后者表示最多显示20个字符，但是存储空间还是占4字节存储，存储范围不变；
什么是存储过程？用什么来调用？答：存储过程是一个预编译的SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL ，使用存储过程比单纯SQL 语句执行要快。可以用一个命令对象来调用存储过程。
什么是触发器？触发器的作用？答：触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。
存储过程与触发器的区别答：触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。
索引的作用？和它的优点缺点是什么？答：索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。
MySQL主要的索引类型普通索引：是最基本的索引，它没有任何限制；唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一；主键索引：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值；组合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合；全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较，mysql中MyISAM支持全文索引而InnoDB不支持；
使用like 'a%' 、like'%a'、like'%a%'查询时是否会使用索引答：'a%'会，其他两个不会；
使用索引注意事项索引不会包含有NULL的列，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的；使用短索引，对串列进行索引，如果可以就应该指定一个前缀长度；短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作；mysql查询只使用一个索引，因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引；注意like，上文已经提到；不要在列上进行运算；不使用NOT IN 、<>、！=操作，但<,<=，=，>,>=,BETWEEN,IN是可以用到索引的；索引要建立在经常进行select操作的字段上；索引要建立在值比较唯一的字段上；对于那些定义为text、image和bit数据类型的列不应该增加索引；在where和join中出现的列需要建立索引；如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引；在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用；
说一说什么是外键，优缺点答：外键指的是外键约束，目的是保持数据一致性，完整性，控制存储在外键表中的数据。使两张表形成关联，外键只能引用外表中列的值；优点：由数据库自身保证数据一致性，完整性，更可靠，因为程序很难100％保证数据的完整性，而用外键即使在数据库服务器当机或者出现其他问题的时候，也能够最大限度的保证数据的一致性和完整性。有主外键的数据库设计可以增加ER图的可读性，这点在数据库设计时非常重要。外键在一定程度上说明的业务逻辑，会使设计周到具体全面。缺点：可以用触发器或应用程序保证数据的完整性；过分强调或者说使用外键会平添开发难度，导致表过多，更改业务困难，扩展困难等问题；不用外键时数据管理简单，操作方便，性能高（导入导出等操作，在insert, update, delete 数据的时候更快）；
在什么时候你会选择使用外键，为什么答：在我的业务逻辑非常简单，业务一旦确定不会轻易更改，表结构简单，业务量小的时候我会选择使用外键。因为当不符合以上条件的时候，外键会影响业务的扩展和修改，当数据量庞大时，会严重影响增删改查的效率。
什么叫视图？游标是什么？视图是一种虚拟的表，具有和物理表相同的功能；可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。
mysql有没有rowid？答：没有，InnoDB如果没有定义主键，内部会生成一个主键编号rowid ，但是无法查询到。在平时InnoDB建表的时候我们最好自己确定主键，防止每次插入数据前数据库会去生成rowid。
mysql怎么在查询时给查出来的数据设置一个自增的序号？set @i=0;SELECT (@i:=@i+1) 别名 FROM table, (SELECT @i:=0) AS 别名 ;
如何使用explain优化sql和索引？explain sql ;table：显示这一行的数据是关于哪张表的；type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL；all: full table scan ;MySQL将遍历全表以找到匹配的行；index ： index scan; index 和 all的区别在于index类型只遍历索引；range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，< ,>等查询；ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型；如果将主键置于where列表中，MySQL就能将该查询转化为一个常量；possible_keys：显示可能应用在这张表中的索引；如果为空，没有可能的索引；可以为相关的域从WHERE语句中选择一个合适的语句；key： 实际使用的索引；如果为NULL，则没有使用索引；很少的情况下，MySQL会选择优化不足的索引；这种情况下，可以在SELECT语句中使用USE INDEX(indexname)来强制使用一个索引或者用IGNORE INDEX(indexname)来强制MySQL忽略索引key_len：使用的索引的长度；在不损失精确性的情况下，长度越短越好；ref：显示索引的哪一列被使用了，如果可能的话，是一个常数；rows：MySQL认为必须检查的用来返回请求数据的行数；Extra：关于MySQL如何解析查询的额外信息；
以上就是阿伟暂时对mysql面试题的总结，mysql能问的当然不止那么多，不过咱们都是干后端开发，也不是专业的DBA，所以这30题能满足大部分程序猿的需求，当然如果你想更好的复习mysql相关知识，还要多做笔试题，多写写sql才行；

# 参考
数据库常见面试题（附答案）
原文链接：https://blog.csdn.net/qq_22222499/article/details/79060495

mysql数据库面试题大全https://www.cnblogs.com/ronglianbing/p/11823230.html

MySql面试题及答案大全https://baijiahao.baidu.com/s?id=1626325768515979989&wfr=spider&for=pc

精选Java数据库面试题及答案http://www.bjpowernode.com/javazixun/3181.html

史上最全的数据库面试题，不看绝对后悔https://www.cnblogs.com/wenxiaofei/p/9853682.html
