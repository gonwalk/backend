
# 索引与数据结构

索引是帮助MySQL高效获取数据的排好序的数据结构。

常用的索引的数据结构有：
```markdown
- B+树
- 红黑树：Java JDK1.8及之后的HashMap被优化为红黑树数据结构
- Hash
- 二叉树
- B-树
```


## 索引的缺点

虽然使用索引有很多好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：

```markdown
- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。
- 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果在一个大表上创建了多种组合索引，索引文件会膨胀很快。

```

索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。

## InnoDb存储引擎索引概述

InnoDB存储引擎支持几种常见的索引：
- B+树索引
- 全文索引
- 哈希索引

InnoDB存储引擎支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能认为干预是否在一张表中生成哈希索引的生成。

B+树索引就是传统意义上的索引，这是关系型数据库系统中查找最为常用和最为有效的索引。B+树索引的构造类似于二叉树，根据键值快速找到数据。

- 注意：B+树中的B不是代表二叉（binary）树，而是代表平衡（balance），因为B+树是从最早的平衡二叉树演化而来的，但是B+树不是一个二叉树。 

## 数据结构与算法

B+树索引是在数据库中使用最为频繁的一种索引。

### 二叉查找树和平衡二叉树

B+树是通过二叉查找树，再由平衡二叉树，B树演化而来。

#### 二叉查找树

在二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。因此可以通过中序遍历得到（二叉查找树）键值的排序输出。

一个数字序列对应的二叉查找树可以任意构造，构造出的结构可能是多样的，而查询效率也会有所差别。因此若想最大性能低构造一颗二叉查找树，需要这颗二叉查找树是平衡的，这就是平衡二叉树，或称为AVL树。

#### 平衡二叉树

平衡二叉树定义：
1. 满足二叉查找树的定义；
2. 满足任何节点的两个子树的高度最大差为1。

平衡二叉树的查找性能是比较高的，但不是最高的，只是接近最高性能。性能最好的是最优二叉树，但最优二叉树的建立和维护需要大量的操作，因此，用户一般只需建立一颗平衡二叉树即可。

维护一颗平衡二叉树的代价是很大的，通常需要一次或多次左旋和右旋来得到插入或更新后树的平衡性。

对于图1中的平衡树，当插入9时，需要做图2所示的变动。

![图1](database/pictures/二叉查找树.png "平衡查找树")

![图2](database\pictures\插入键值9，平衡二叉树变化.png "插入键值9后平衡二叉树变化")

![图3](database\pictures\需多次旋转的平衡二叉树.png "需要多次旋转的二叉树")

向一颗平衡二叉树插入、删除、更新一个新的节点后，需要通过左旋或者右旋来保持新的平衡状态，因此对一颗平衡树的维护是有一定开销的。平衡二叉树多用于内存结构对象中，因此为何的开销相对较小。

## B+树

B+树由B树和索引顺序访问方法（ISAM，这是MyISAM查询引擎最初参考的数据结构）演化而来，但是在现实使用过程中几乎没有使用B树的情况了。

B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。在B+树中，所有记录节点都是按照键值的大小顺序存放在同一层叶子节点上，由各个叶子节点指针进行连接。

## B+树索引

B+树索引的本质就是B+树在数据库中的实现。B+树在数据库中有一个特点是高扇出性，因此在数据库中，B+树的高度一般都在2~4层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO。当前一般的机械硬盘每秒至少可以做100次IO，2~4次的IO意味着查询时间只需0.02 ~ 0.04秒。

数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），不管是哪种索引，其内部都是B+树，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的地方在于，叶子节点存放的是否是一整行的信息。

### 聚集索引（叶子节点存放的是行记录数据）

聚集索引按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的行记录数据。每张表只能有一个聚集索引。

#### 聚集索引组织架构

InnoDB存储引擎是索引组织表，即表中的数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。

由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能有一个聚集索引。在多数情况下，查询优化器倾向于采用聚集索引，因为聚集索引能够在B+树索引的叶子节点上直接找到数据。由于定义了数据的（主键）逻辑顺序，聚集索引能够非常快地访问针对范围内的查询。

数据页上存放的是完成的每页的记录，而在非数据页的索引页中，存放的仅仅是键值以及指向数据页的偏移量，而不是一个完整的行记录。

#### 聚集索引特点

聚集索引按照顺序物理地存储数据，其存储顺序并不是物理上连续的，而是逻辑（主键）上连续的。其中有两点原因：其一是页通过双向链表进行链接，并按照主键的顺序进行排序；其二是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。

聚集索引的另一个好处是，它对于主键的排序查找（order by）和范围查找（大于>或小于<某个范围）速度非常快。叶子节点的数据就是用户所要查询的数据。


通过explain关键字获取mysql语句的执行计划（execute plan），及执行过程的解释。如：
mysql> explain
mysql> select * from student order by id limit 3;


### 辅助索引（也称为非聚集索引，叶子节点存放行数据的指针）

辅助索引（Secondary Index，也称为非聚集索引），叶子节点并不存放行记录的数据，而是指向具体行数据的指针。

辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引去查找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后通过主键索引找到完整的行记录。

### 聚集索引与非聚集索引的区别

```
聚集索引的叶子节点存放的是具体的行数据，一张表只能有一个聚集索引。
非聚集索引的叶子节点存放的是指向行数据的指针，一张表可以有多个聚集索引。
```


## 哈希
直接寻址法可以用一个数组表示动态的集合，其缺点：如果域U很大，在计算机的可用容量限制下，要在机器中存储大小为U的一张表T就不太方便。而且当实际要存储的关键字集合K相对于U很小时，分配给T的大部分空间就会被浪费掉。

### 链接表法——解决哈希碰撞

哈希表技术能很好地解决直接寻址遇到的问题，但是当两个关键字映射到同一个槽上时，会发生哈希碰撞（collision）。在数据库中一般采用最简单的碰撞解决技术，即链接（表）法（chaining）。

在链接表法中，把散列到同一槽中的所有元素都放在一个链表中。哈希值对应的每个槽中，有一个指针，它指向由所有散列到该槽的元素构成的链表的表头；如果不存在这样的元素（即元素对应的哈希值不在哈希函数对应的哈希值的散列值范围内），那么该槽对应的值就为NULL。

### 哈希函数选择

哈希函数的选择原则是，尽可能避免哈希碰撞的发生。一般来说，都会将关键字转换成自然数，然后通过除法（取余）散列、乘法散列、或全域散列来实现。数据库 中一般采用除法散列的方式。

### InnoDB存储引擎中的哈希算法

InnoDB存储引擎使用哈希算法来对字典进行查找，其冲突机制采用链表方式，哈希函数采用除法（取余）散列方式，即h(k) = k mod m，其中k是（转换后的）关键字（对应的自然数），m一般取相应的质数。

对于缓冲池页的哈希表来说，在缓冲池中的Page页都有一个chain指针，它指向相同哈希函数值的页。而对于除法散列，m的取值为略大于2倍的缓冲池页数量的质数。比如：当前参数innodb_buffer_pool_size的大小为10M（等于10 * 2^10 KB = 2^6 *10 * 2^4KB = 640 * 16KB），则公有640个16KB的页。对于缓冲池页内存的哈希表来说，需要分配640 * 2 = 1280个槽，但是由于1280不是质数，需要取比1280略大的一个质数1399，所以在启动时会分配1399个槽的哈希表，用来哈希查询所在的缓冲池中的页。

InnoDB存储引擎的缓冲池对于其中的页是如何进行查找的，要查找的页如何转换成自然数呢？

InnoDB存储引擎的表空间都有一个space_id，用户需要查询的应该是某个表空间的某个连续16KB的页，即偏移量offset。InnoDB存储引擎将space_id左移20位，然后加上这个space_id和offset，即关键字K = space_id<<20 + offset，然后通过除法散列到各个槽中。

### 自适应哈希索引

自适应哈希索引采用哈希表的方式实现，不同的是，这仅是数据库自身创建并使用的，用户无感知，DBA本身并不能对其进行干预。

自适应哈希索引经哈希函数映射到一个哈希表中，因此对于字典类型的查找非常快，如select * from table index_col = 'xxx'。但是对于范围查找，可能需要扫描全表。通过命令SHOW ENGINE INNODB STATUS可以看到当前自适应哈希索引的使用状况。







### sql 中count 在innodb 和myisam 表类型的查询快慢比较

原文链接：https://blog.csdn.net/weixin_42678790/article/details/82908296

在sql中经常会用到count(*) 或者不常用的count(‘列’),在innodb和myisam 的查询速度有多大,原理又是什么?
下面我们首先唠唠myisam和innodb主要区别
```
1).MyISAM是非事务安全型的，而InnoDB是事务安全型的。
2).MyISAM锁的粒度是表级，而InnoDB支持行级锁定。
3).MyISAM支持全文类型索引，而InnoDB不支持全文索引。
4).MyISAM不支持外键，而InnoDB支持外键，对一个包含外键的InnoDB表转为MYISAM会失败。 
5).InnoDB（索引组织表）使用的是聚簇索引，其索引就是数据，顺序存储，因此能缓存索引，也能缓存数据。
MyISAM（堆组织表）使用的是非聚簇索引，其索引和文件（数据）分开，随机存储，只能缓存索引。



6).MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。
7).MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。
8).InnoDB表比MyISAM表更安全。
```
myisam 和 innodb中count(*)查询快慢原理：

在myisam中使用不带条件的count(*)查询时，myisam引擎很容易获得总行数的统计，其查询速度比innodb快得多。因为myisam存储引擎已经存储了表的总行数，当每次新增加一行时，这个计数器就加1。也就是说，myisam存储引擎把表的总数缓存在索引中了。

注意一点

**：myisam存储引擎的表，count()速度快的也仅仅是不带where条件的count。这个想想容易理解的，因为你带了where限制条件，原来所以中缓存的表总数能够直接返回用吗？不能用。这个查询引擎也是需要根据where条件去表中扫描数据，进行统计返回的。

**：针对Innodb表,尽量不执行 SELECT COUNT() 语句,因为Innodb表没有类似MyISAM那样的内部计数器来记录表记录总量,执行这个操作将会全表扫描，速度很慢。所以呢，表的行数越多，扫描的时间就越多。当你表行数还是小数量的时候体会不出速度差距。比如百万也感觉不出明显。上千万就会很明显速度差别了。

比较得知:myisam 中count() 不带where条件下较innodb快很多


那么为什么count(*) 加where条件,同样是全表扫描myisam 比innodb查询要快勒?
because…
INNODB在做SELECT的时候，要维护的东西比MYISAM引擎多很多；
1）INNODB要缓存数据块，MYISAM只缓存索引块， 这中间还有换进换出的减少；
2）innodb寻址要映射到块，再到行，MYISAM 记录的直接是文件的OFFSET，定位比INNODB要快

