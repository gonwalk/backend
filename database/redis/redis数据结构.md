# 1.基本数据结构

字符串string、列表list、集合set、有序集合sorted set、哈希hash。


# 2.哈希



## 2.1 哈希
Redis Hash：https://www.jianshu.com/p/28d4198085c8

什么是哈希
哈希hash又称为散列、杂凑等，是将任意长度的输入通过散列算法变换为固定长度的输出，最终输出也就是哈希值。这种转换是一种压缩映射。也就是说，散列值的空间通常要远小于输入控件，不同的输入可能会散列成相同的输出，所以不可能通过散列值来确定唯一的输入值。

哈希
什么是哈希表
哈希表hash table是为了将数据映射到数组中某个位置，通过数组下标访问元素以提高数据的查询速度，这种查询的平均期望时间复杂度为O(1)。

例如：有4个整数分别为6、7、9、12，需要映射到数组中。

方案1：新开一个长度为13的数组，将对应值放置到对应的下标。

下标对应
问题是这样做，会浪费没有被映射到的位置的空间。

方案2：采用哈希表的做法，申请长度为4的数组，将每个数的值对数组长度4取模，然后放置到对应的数组槽位中，这样就把离散的数据映射到了连续的空间，所以哈希表又称为散列表。

哈希表
采用哈希表的好处是最大限度地提升空间的利用率，而且查询效率还很高。不过问题来了，如果这4个数是6、7、8、11呢？由于7和11对4取模的值都是3，所以它们会占据同一个槽位。

散列冲突
这种情况我们称为冲突(collision)，解决冲突的方式有开放地址法、再散列法、链地址法等。Redis采用的是链地址法，简单来说，链地址法就是将有冲突的数据用一个链表给串联起来。

链地址法
使用链地址法，就算有冲突也可以将有冲突的数据存储在一起。只是存储结构需要稍加变化，哈希表的每个元素将变成一个指针，指向数据链表的链表头，每次有新数据来时从链表头插入，可以达到插入的时间复杂度保持在O(1)。

Redis中的字典
在Redis中，hash哈希被称为字典（dictionary），Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点保存了字典中的一个键值对。实际上，Redis数据库底层也是采用哈希表来存储键值对的。

Redis中的字典
Redis中的哈希采用了典型的挂链解决冲突的方式，当有多个key-value键值对的键名key映射值相同时，系统会将这些键值value以单链表的形式保存，同时为了控制哈希表占用内存大小，Redis采用了双哈希表ht[2]结构，并逐步扩大哈希表容量的策略。注意，每对key-value在保存前会通过类似HASH(key) MOD N的方法计算出一个值，以确定在哈希表中所对应的位置。

Redis hash数据结构
Redis中一个哈希存储一条数据，一个字段field则存储一条数据中的一个属性，字段值value是属性对应的值。每个哈希hash可存储2^32-1个键值对，约40多亿个。Redis中的哈希散列类型与Java中的HashMap相似，都是一组键值对的集合，并且支持单独对其中一个键进行增删改查操作。

哈希键值对
为什么哈希更适合存储对象呢？
哈希存储对象
Redis中的哈希散列适用于存储对象，将一个对象存储在哈希类型中会占用更小的内存。将对象的每个字段存储为单个的string字符串类型，进而将一个对象存储在hash类型中，这样会占用更少的内存并能更方便的存储整个对象。

哈希存储对象
为什么使用哈希会更加节省内存呢？
Redis中的哈希散列是一个string类型的field和value的映射表，它的增删操作的复杂度平均为O(1)。为什么平均是O(1)呢？因为哈希的内部结构包含zipmap和hash两种。hash适合存储对象，相对于对象序列化存储为string字符串类型，将对象存储在hash哈希类型中会占用更少的内存。zipmap本身并不是hashtable，由于zip压缩后可以节省hash本身所需的元数据的开销。因此zipmap的增删改查的操作复杂度为O(n)。但是域字段field的数量不多，所以说平均是O(1)。那么，为什么会占用更好的内存呢？因为对象刚开始使用的是zipmap存储的。

在新建一个哈希的时候，使用的是zipmap又称为small hash存储的。这个zipmap实际上不是我们的哈希表。但是这个zipmap相比正常的哈希实现，节省很多哈希自身所需要的元数据的存储开销。尽管zipmap的增删改查和字段的数目相关，字段太多速度会更慢。因此不建议设置过多的字段。在Redis内部，如果字段过多或者存储的值太大超过限制后，Redis会自动将zipmap替换为正常的hash来实现。

在域字段field的数量在限制范围内，并且字段值value的长度大小系统限定的字节数，此时哈希类型是用zipmap存储的，所以会比较节省内存空间。

# 配置域字段最大个数限制
hash-max-zipmap-entries 512

# 配置字段值最大字节限制
hash-max-zipmap-value 64
当满足以上两个条件时，哈希表key会被压缩，否则将按照正常的哈希结构来存储。

Redis中哈希与集合的异同点
哈希与集合
set以普通的key-value键值对的方式存储，可以设置过期时间，时间复杂度为O(1)，每执行一个set就会在Redis中多出一个key。

hset是以哈希散列表的形式存储，超时时间只能设置在键key上，单个域field不能设置过期时间。时间复杂度为O(n)，n是单个哈希上的field域个数。所以，单个哈希并不适合存储大量的字段field，过多的字段field会比较消耗CPU。但优点在于散列表存储会比较节省内存。

实际应用中，应该使用set集合存储单个大文本的非结构化数据，使用hset哈希散列表来存储结构化数据。

Redis中对哈希的操作
Redis中对hash类型的操作
hset key field value

将哈希表key中的字段field的值设置为value，若key不存在则创建后赋值，若域field已存在则覆盖。
Redis中hset命令用于为哈希表中的字段赋值，如果哈希表不存在则创建并进行字段赋值，否则原字段值将被新字段值所覆盖。
若字段是哈希表中新建的字段且字段值设置成功则返回1，若哈希表中域字段已经存在且 旧值被新值覆盖成功则返回0。
$ redis-cli
127.0.0.1:6379> hset username "junchow"
(error) ERR wrong number of arguments for 'hset' command

# 错误：set或map的size为0，一个没有值的set或map。





## 哈希冲突与解决

redis字典 - 哈希算法，解决键冲突， rehash , 渐进式rehash,字典API
http://www.manongjc.com/article/17720.html

