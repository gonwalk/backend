
Redis常见面试题：https://www.cnblogs.com/jasontec/p/9699242.html

几率大的Redis面试题（含答案）：https://blog.csdn.net/Butterfly_resting/article/details/89668661
# 0.Redis简介
Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。

Redis 是一个高性能的key-value数据库。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集、并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。

Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。

# 1.Redis持久化机制

Redis是一个单线程（客户端源源不断地更新命令到服务端，某一时刻只能执行一件事情）的，分布式缓存数据库。
Redis持久化机制有两种：RDB持久化（默认），AOF持久化。

## 1.1 Redis持久化原理

Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。

实现方式：（从redis主进程）单独创建（复制fork）一个与当前进程一模一样的子进程，将当前父进程数据库中的数据（变量、配置的环境设置、程序计数器等）复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束后，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。在持久化的整个过程中，主进程不进行任何的IO操作，这样就保证了极高的性能。

实现过程：redis主进程 -> fork复制一个子进程 -> 主进程DB中的数据复制到子进程内存 -> 子进程写入到临时文件tmp中 -> 临时文件tmp替换上次的快照 -> 子进程退出 -> 内存释放。

## 1.2 Redis实现持久化的两种方式

### 1.2.1 RDB持久化方式：将数据定期同步到数据文件

RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件中。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）

save命令指定在多长时间内，有多少次更新（增删改，查不算）操作，就将数据同步到数据文件，可以多个条件配合使用，如下面的示例是3个条件一起使用。如果想禁用RDB持久化的策略，只要不设置任何save命令，或者给save传入一个空字符串也可以禁用RDB持久化方式，如save ""。Redis调优的一种方式就是调节save更新的时间和次数。

save参数形式如下：save 触发更新操作的周期 更新操作次数
```
save 900 1      #表示900秒内有1个更改就触发RDB持久化
save 300 10     #表示300秒内有10个更改
save 60 10000   #表示60秒内有10000个更改
```

什么时候fork子进程，或者什么时候触发RDB持久化机制？

（1）Redis在shutdown关闭的时候，如果没有开启AOF，就会触发。
（2）使用配置文件中默认的快照设置。
（3）执行save或者bgsave命令。其中save命令，只管保存，其他设置会忽略，主进程的所有更新操作都会被全部阻塞。bgsave命令，Redis会在后台异步进行快照操作，同时可以响应客户端的请求。
（4）执行flushall命令，但是里面是空的，无意义。

### 1.2.2 AOF持久化方式：将每个命令追加到文件末尾

1）AOF持久化原理

AOF（append only file）：Redis会将每一个收到的写（增删改，不包括查询命令）命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启时，会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。

AOF持久化方式（默认使用everysec，即每秒同步一次命令）最慢不超过1秒，所以相对于RDB持久化方式（一般设置60秒及以上的时间，才会将数据同步到快照中），其丢失的数据会更少。

Redis4.0后，提供了以上两种模式的混合。当RDB和AOF两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。

2）AOF触发机制

下面是配置文件中的配置项进行触发AOF持久化的参数：
```
no：表示等操作系统进行数据缓存同步到磁盘。该种方式，持久化速度快，但是没有保证。
always：同步持久化，即每次发生数据变更时，立即将更新命令追加到磁盘中。该种方式，持久化速度慢（Redis最快可以1秒更新1W条数据），但是安全。
everysec：表示每秒同步一次。该方式是默认值，当开启AOF时默认使用该模式，即每秒同步一次。该方式速度很快，但可能会丢失一秒以内的数据。
```

3）AOF重写机制

当AOF文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当AOF文件大小的增长率大于该配置项时，自动开启重写（下面指的是超过原大小的100%）。
```
auto-aof-rewrite-percentage 100
```
当AOF文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当AOF文件的大小大于该配置项的值时，自动开启重写。默认达到64MB时，就会重写。实际的生产环境，对Redis进行优化时一般会该项的值，可以设置为4GB。
```
auto-aof-rewrite-min-size 64mb
```

# 2.Redis集群三种模式

对于传统的Redis（单机模式），通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据。

但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。

参考：https://www.jianshu.com/p/8e1ed39fdab3

Redis集群主要有以下几种模式：
```markdown
- 主从模式：
- 哨兵模式：中小公司一般用这种模式。哨兵模式是在主从模式的基础上，添加额外的哨兵节点，当主机节点挂掉后，哨兵节点在从节点中选取一个作为主机节点（可以解决单点故障问题）。刚主机挂掉时，在挂掉的这几秒里，服务不可用，所以对于大公司是不可容忍的，一般小公司可以用这种方式。
- cluster模式
```

## 2.1 主从模式

Redis的主从复制指的是：当主机的数据更新后，根据配置和策略，自动同步到从机上去，这就是Redis集群的master/slave主从复制机制。其中master以写为主，slave机器以读为主。

在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

### 2.1.1 单机模式存在的问题

```markdown
- 单机故障
- 容量瓶颈
- QPS瓶颈
```

### 2.1.2 Redis主从复制的优势

1.读写分离：master机器进行写操作，slave机器读取；
2.


### 2.1.3 主从数据库的配置

主数据库不用配置，redis中从数据库的conf文件中可以加载从数据库的信息，也可以在启动时，使用 redis-server --port 6380 --slaveof 127.0.0.1 6379
从数据库一般是只读，可以改为可写，但写入的数据很容易被主数据库同步没，所以还是只读就可以。
也可以在运行时使用slaveof ip port命令，停止原来的主，切换成刚刚设置的主，而slaveof no one会把自己变成主。

### 2.1.4 复制原理

```markdown
（1）当从数据库启动时，会向主数据库发送sync命令；
（2）主数据库接收到sync后开始在后台保存快照rdb，在保存快照期间会将收到的命令缓存起来；
（3）当快照完成时，主数据库会将快照和缓存的命令一块发送给从数据库。
```
复制初始化结束之后，主每收到1个命令就同步发送给从数据库。
当出现断开重连后，对于redis2.8之后的版本，其会将连接断开期间的命令传给从数据库。

主从复制是乐观复制，当客户端发送写操作给主数据库，主数据库执行完立即将结果返回客户端，并异步地把命令发送给从，从而不影响性能。也可以设置至少同步给多少个从数据库后，主数据库才可以进行写。

无硬盘复制：如果硬盘效率低将会影响复制性能，redis2.8版本之后可以设置无硬盘复制，repl-diskless-sync yes

## 2.2 哨兵模式

当主数据库遇到异常中断服务后，开发者可以通过手动的方式选择一个从数据库来升格为主数据库，以使得系统能够继续提供服务。然而整个过程相对麻烦且需要人工介入，难以实现自动化。 为此，Redis2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。
哨兵的作用就是监控redis主、从数据库是否正常运行，主出现故障自动将从数据库转换为主数据库。
例子：
1主 2从 1哨兵

redis-server --port 6379 
redis-server --port 6380 --slaveof 192.168.0.167 6379 
redis-server --port 6381 --slaveof 192.168.0.167 6379
哨兵配置文件 sentinel.conf 
 sentinel monitor mymaster 192.168.0.167 6379  1
这里的1代表1个哨兵
注：
配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库

这样哨兵就能监控主6379和从6380、6381，一旦6379挂掉，哨兵就会在2个从中选择一个作为主，根据优先级选，如果一样就选个id小的，当6379再起来就作为从存在。

## 2.3 集群(cluster-enable)模式

使用集群，只需要将每个数据库节点的cluster-enable配置打开即可。每个集群中至少需要三个主数据库才能正常运行。

即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据，浪费内存且有木桶效应。为了最大化利用内存，可以采用集群，就是分布式存储。即每台redis存储不同的内容。
集群至少需要3主3从，且每个实例使用不同的配置文件，主从不用配置，集群会自己选。
修改每个实例的配置文件：

 cluster-enabled yes  --开启集群
 cluster-config-file nodes-6382.conf --集群配置文件名，
每个实例配置的要不同，redis会根据文件名自动新建
集群的运行

redis安装目录的src执行./redis-trib.rb create --replicas 1 
127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 
127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385
这里的master选举和zookeeper的相似




# 3.缓存的几大问题

在面试过程中，常问的缓存的问题有：缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题。

## 3.1 缓存击穿（缓存中没有，数据库中有，一般是缓存到期）

缓存击穿，可以理解为击穿缓存（未穿透数据库），是指对缓存中没有但是数据库中有的数据（一般是指缓存时间到期），这是由于并发用户特别多，同时在缓存中没有读取到数据，就会造成大并发量地去数据库中查询。
当一个key是非常热点的数据，如微博热点事件，这个key在不停的扛着大并发，大并发集中对这一个点（的数据）进行访问，当这个key在失效（默认设置的缓存失效时间过期）的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

其实，大多数情况下这种情况也很难对数据库服务器造成压垮性的压力，能达到这么高并发量的公司，肯定会对这些热点数据做处理。面对这种情况，比较务实主义的做法，就是对热点数据早早地做好准备，直接将其设为永不过期就好。

解决方案：一般采用加锁的方式，如：互斥锁、JVM锁、分布式锁

如果项目在多台机器上都有部署，即采用分布式的部署方式，可以使用JVM锁；当项目采用多机器部署的方式，则使用分布式锁。

## 3.2 缓存穿透（缓存、数据库都没有）

缓存穿透，可以理解为击穿缓存后又穿透数据库，是指用户要查询的数据，在数据库中不存在，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，缓存没有起到应有的保护数据库的作用，这就是缓存穿透（数据库）问题，这也是经常提的缓存命中率问题。

解决办法：布隆过滤器、将空值缓存起来。

最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层（数据库）存储系统的查询压力。

另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。


## 3.3 缓冲雪崩（大量缓存同一时刻过期，同时请求去查DB）

当缓存服务器重启或者原缓存在同一时刻大量失效/过期，新缓存未到，造成原本访问缓冲的查询请求都去查询数据库。

(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。

解决办法：
```markdown
- 搭建高可用集群，保证机器的高可用性；
- 对不同的人数据使用不同的失效时间，设置对相同的数据、不同的请求使用不同的失效时间
```
大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免缓存失效时大量的并发请求落到底层存储系统上。还有一个简单方案就是将缓存失效时间分散开，如使用随机时间。

## 3.4 缓存与数据一致性问题

redis多机部署方式有哪些？如何保证数据一致的？
主从复制、集群模式，读写分离

一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。

造成数据不一致问题的原因：
假设有两个线程A和B，同时维护者缓存cache，如果某一时刻，由于网络等原因，线程B比A先更新了缓存，就会造成脏数据（不一致）。

线程A -> cache读（更新）数据 -> 数据库db;
线程B -> cache读（更新）数据 -> 数据库db;

先删除缓存，再修改数据库。
如果数据库修改失败，那么数据库中的数据是旧数据，会造成数据不一致问题。因为先去缓存中去读，发现缓存是空的，然后去数据库中查询，查出来的是旧数据，然后又将旧数据set到缓存中，这样还是没有达到更新的目的，还是会数据不一致。

解决方案：
```
- 延迟双删；
- 串行化
    先在队列（先进先出）中更新数据库，再查询数据库，更新缓存：
    线程A删除缓存后；然后更新缓存，加入队列中；
    线程B查询缓存，发现为空；查询数据库，将其加入队列。
```


### 缓存预热
缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！
解决思路：
1、直接写个缓存刷新页面，上线时手工操作下；
2、数据量不大，可以在项目启动的时候自动进行加载；
3、定时刷新缓存；

### 缓存更新
除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：
（1）定时去清理过期的缓存；
（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。
两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。
### 缓存降级
当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。
降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。
以参考日志级别设置预案：
（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。

## 热点数据和冷数据是什么
热点数据，缓存才有价值。
对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存
对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。
对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。
**数据更新前至少读取两次，**缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。
那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。

## Memcache与Redis的区别都有哪些？
1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据。
2)、数据支持类型 memcached所有的值均是简单的字符串；redis作为其替代者，支持更为丰富的数据类型，提供list，set，zset，hash等数据结构的存储。
3)、使用底层模型不同。它们之间底层实现方式以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
4) value 值大小不同：Redis 最大可以达到 1GB；memcache 只有 1MB。
5）redis的速度比memcached快很多。
6）Redis支持数据的备份，即master-slave模式的数据备份。

## 单线程的redis为什么这么快
(一)纯内存操作
(二)单线程操作，避免了频繁的上下文切换
(三)采用了非阻塞I/O多路复用机制



# Redis 内部结构
dict 本质上是为了解决算法中的查找问题（Searching）是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。 本质上是为了解决算法中的查找问题（Searching）
sds sds就等同于char * 它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结 束，因此它必然有个长度字段。
skiplist （跳跃表） 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现，
quicklist
ziplist 压缩表 ziplist是一个编码后的列表，是由一系列特殊编码的连续内存块组成的顺序型数据结构，
redis的过期策略以及内存淘汰机制
redis采用的是定期删除+惰性删除策略。
为什么不用定时删除策略?
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.
定期删除+惰性删除是如何工作的呢?
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。
采用定期删除+惰性删除就没其他问题了么?
不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。
在redis.conf中有一行配置

maxmemory-policy volatile-lru
1
该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)
volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据，新写入操作会报错
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。

## redis的数据类型，以及每种数据类型的使用场景
回答：一共五种
(一)String
这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。
(二)hash
这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
(三)list
使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。还用一个场景，很合适生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。

(四)set
因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。
另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
(五)sorted set
sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。




同时有多个子系统去set一个key。这个时候要注意什么呢？ 不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。
(1)如果对这个key操作，不要求顺序： 准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可
(2)如果对这个key操作，要求顺序： 分布式锁+时间戳。 假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。
(3) 利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性
对redis的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis内部已经帮你处理好并发的问题了。

Redis 集群方案应该怎么做？都有哪些方案？
1.twemproxy，大概概念是，它类似于一个代理方式， 使用时在本需要连接 redis 的地方改为连接 twemproxy， 它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再返回 twemproxy。
缺点： twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。

2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点

3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。



Redis 常见性能问题和解决方案？
(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master <- Slave1 <- Slave2 <-
Slave3…


# Redis在保证效率的情况下如何保证一致性

## Redis 为什么是单线程的
官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问
1）绝大部分请求是纯粹的内存操作（非常快速）
2）采用单线程,避免了不必要的上下文切换和竞争条件
3）非阻塞IO优点：
1. 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
2. 支持丰富数据类型，支持string，list，set，sorted set，hash
3. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题

## 对于大量的请求怎么样处理
redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求；
redis是通过IO多路复用（select，epoll, kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求的

## 讲解下Redis线程模型
文件事件处理器包括分别是套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。
I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。
工作原理：
1)I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。
尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字.



# Redis事务
Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的
Redis会将一个事务中的所有命令序列化，然后按顺序执行。
1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行；
3.如果在一个事务中出现运行错误，那么正确的命令会被执行。

1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。
3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。

Redis实现分布式锁
Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。
将 key 的值设为 value ，当且仅当 key 不存在。 若给定的 key 已经存在，则 SETNX 不做任何动作

解锁：使用 del key 命令就能释放锁
解决死锁：
1）通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。
2） 使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。
————————————————
版权声明：本文为CSDN博主「睶先森」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Butterfly_resting/article/details/89668661

## 数据判重

5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？

对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。
### Bitmap： 典型的就是哈希表
缺点是，Bitmap对于每个元素只能记录1bit的信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。

### 布隆过滤器（推荐）
通过引入k(k>1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。

它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。
Hash存在一个冲突（碰撞）的问题，用同一个Hash函数得到的两个不同URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。
Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。