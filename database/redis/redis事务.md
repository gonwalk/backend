# Redis事务

Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。

## Redis事务的概念

　　Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

　　总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令的过程。　

事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

### Redis事务相关命令
```
　　watch key1 key2 ... : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）

　　multi : 标记一个事务块的开始（ queued ）

　　exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　

　　discard : 取消事务，放弃事务块中的所有命令

　　unwatch : 取消watch对所有key的监控
```

示例：
以下是一个事务执行的过程，该事务首先以一个MULTI命令开始，接着将多个命令放入事务中，最后由EXEC命令将这个事务提交（commit）给服务器执行：
```
redis> MULTI                                // 事务开始标志
redis> SET "name" "Practical Common Lisp"   // 中间是多条命令
redis> GET "name"
redis> SET "author" "Peter Seibel"
redis> GET "author"
redis> EXEC                                 // 提交事务给服务器（将多个命令打包，一次性地按照命令的顺序）执行
```

### Redis不保证原子性

　　Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。

### Redis事务没有隔离级别的概念

　　批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。

## 事务的实现

一个事务从开始到结束通常会经历以下三个阶段：
```
1）事务开始
2）命令入队
3）事务执行
```

### 事务开始

MULTI命令的（出现）执行，标志着事务的开始。

MULTI命令可以将执行该命令的客户端从非事务状态切换到事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识完成的。

### 命令入队

当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行，如：
```
redis> SET "name" "Practical Common Lisp"
redis> GET "name"
```

当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：
```
1）如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令中的任意一个，那么服务器立即执行这个命令。
2）如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列中，然后向客户端返回QUEUED回复。
```

### 事务队列
每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性中：
```
typedef struct redisClient {
    // ...
    
    // 事务状态
    multiState mstate;      // MULTI或EXEC state

    // ...
} redisClient;
```

事务状态包含一个事务队列，以及一个已入队命令的计数器（即事务队列的长度）：
```
typedef struct multiState {
    // 事务队列，记录命令的执行顺序，FIFO顺序
    multiCmd *commands;

    // 已入队命令计算
    int count;
} multiState;
```
事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量：
```
typedef struct multiCmd {
    // 参数
    robj **argv;

    // 参数数量
    int argc;

    // 命令指针
    struct redisCommand *cmd;
} multiCmd;
```
事务队列以先进先出（FIFO）的方式保存入队的命令，较先入队的命令会被放在数组的前面，较后入队的命令则会被放到数组的后面。

### 事务执行
当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。

## WATCH命令的实现

WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。

以下是一个事务执行失败的例子：
```
redis> WATCH "name"
OK              // WATCH命令的回复

redis> MULTI
OK

redis> SET "name" "peter'
QUEUED          // 事务中SET命令的回复

redis> EXEC
(nil)
```
客户端对键name进行监视，进行事务处理，在事务中客户端A先设置键name的值为peter，在其执行EXEC命令前，客户端B执行了SET "name" "join'，当客户端A执行到EXEC命令时，服务器发现WATCH监视的键name已经被修改，因此服务器拒绝执行客户端A的事务，并向客户端A返回空回复。

### 使用WATCH命令监视数据库键

每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端：
```
typedef struct redisDb {
    // ...

    // 正在被WATCH命令监视的键
    dict *watched_keys;

    // ...
} redisDb;
```
通过watched_keys字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。

### 监视机制的触发

所有对数据库进行修改的命令，比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等，在执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键。如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏。


### 判断事务是否安全

当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开REDIS_DITRY_CAS标识来决定是否执行事务：
```
（1）如果客户端的REDIS_DITRY_CAS标识已经被打开，说明客户端所监视的键当中，至少有一个键被修改过，在这种情况下，客户端提交的事务已经不再安全，所以服务器会拒绝执行客户端提交的事务。
（2）如果客户端的REDIS_DITRY_CAS标识没有被打开，说明客户端监视的所有键都没有被修改过（或者客户端没有监视任何键），事务仍然是安全的，服务器将执行客户端提交的这个事务。
```

## Redis事务的ACID性质

在传统的关系型数据库中，常用ACID性质来检验事务功能的可靠性和安全性。

在Redis中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性，并且当Redis运行在某种特定的持久化模式下时，事务也具有耐持久性（Durability）。

### 原子性

事务具有原子性指的是，数据库将事务中的多个操作当做一个整体来执行，服务器要么执行事务中的所有操作，要么一个都不执行。

对于Redis的事务来说，事务队列中的命令要么全部都执行，要么一个都不执行，因此，Redis的事务是具有原子性的。

Redis事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。

Redis不支持事务回滚是因为这种复杂的功能和Redis追求简单高效的设计主旨不相符，Redis事务的执行时错误通常都是编程错误产生的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以没有必要为Redis开发事务回滚功能。

### 一致性

“一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。
Redis通过谨慎的错误检测和简单的设计来保持事务的一致性。Redis事务可能出现以下几种常见的错误，通过对这些错误的处理，确保事务的一致性。

#### 入队错误

如果一个事务在执行入队命令的过程中，出现命令不存在，或者命令的格式不正确等情况，那么Redis将拒绝执行这个事务。

因为服务器会拒绝执行入队过程中出现错误的事务，所以Redis事务的一致性不会被夹杂着入队错误的事务影响。

如下，是一个客户端尝试向事务入队一个不存在的命令YAHOOOO，客户端的提交会被服务器拒绝执行：
```
redis> MULTI
OK

redis> SET msg "hello"
QUEUED

redis>YAHOOOO
(error) ERR unknown command 'YAHOOOO'

redis> GET msg
QUEUED

redis> EXEC
(error) EXECABORT Transaction discarded becase of previous errors.
```

#### 执行错误

事务还可能在执行的过程中发生错误:
```
（1）执行过程中发生的错误都是一些不能再入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发。
（2）即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会被出错的命令影响。
```
在事务执行过程中，出错的命令会被服务器标识出来，并进行相应的错误处理，这些出错的命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。

如下示例，是先用SET命令将键"msg"设置为一个字符串键，然后在事务中尝试对"msg"键执行只能用于列表键的RPUSH命令，这将引发一个错误，并且这种错误只能在事务执行期间发现：
```
redis> SET msg "hello"
OK

redis> MULTI
OK

redis> SADD fruit "apple" "banana" "cherry"
QUEUED

redis> RPUSH msg "good bye" "bye bye"
QUEUED

redis> SADD alphabet "a" "b" "c"
QUEUED

redis> EXEC
1) (integer) 3
2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
3) (integer) 3
```

#### 服务器停机

Redis服务器在执行事务的过程中停机，根据服务器所使用的持久化模式，可能有一下情况出现：
```
如果服务器运行在无持久化的内存模式下，Redis服务器在重启后的数据库将是空白的，因此数据总是一致的。
如果服务器运行在RDB模式下，事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个（停机之前的）一致性状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，而空白的数据库总是一致的。
如果服务器运行在AOF模式下，事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据库还原到一个（停机之前的）一致性状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白的数据库总是一致的。
```
综上所述，无论Redis服务器运行在哪种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性。

### 隔离性

事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会相互影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

因为Redis使用单线程的方式执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务总是具有隔离性。

### 持久性

事务的持久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如磁盘）里面，即使服务器在执行完毕后停机，执行事务所得的结果也不会丢失改变。

由于Redis的事务是通过简单地用队列包裹起来一组Redis命令，Redis并没有为事务提供任何额外的持久化功能，所以Redis事务的持久性由Redis所使用的持久化模式决定：
```
（1）当服务器在无持久化的内存模式下运作时，事务不具有持久性：一旦服务器停机，包括事务数据在内的所有服务器数据都将丢失。
（2）当服务器在RDB持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行BGSAVE命令，对数据库进行保存操作，并且异步执行的BGSAVE不能保证事务数据被第一时间保存到硬盘里面，因此RDB持久化模式下的事务不具有持久性。
（3）当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘中，因此这种配置下的事务具有持久性。
（4）当服务器运行在AOF持久化模式下，并且appendfsync选项的值为everysec时，程序会每秒同步一次命令数据到硬盘中。由于停机可能恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，因此这种配置下的事务不具有持久性。
（5）当服务器运行在AOF持久化模式下，并且appendfsync选项的值为no时，程序会交由操作系统决定何时将命令数据同步到硬盘中。由于事务数据可能在等待同步的过程中丢失，因此这种配置下的事务不具有持久性。
```
不论Redis在什么模式下运作，在一个事务的最后加上SAVE命令总可以保证事务的持久性。
```
redis> MULTI
OK

redis> SET msg "hello"
QUEUED

redis> SAVE
QUEUED

redis> EXEC
1) OK
2) OK
```