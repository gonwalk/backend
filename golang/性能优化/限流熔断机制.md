
# 1.限流

对于秒杀系统的挑战是：在流量瞬时突增的情况下，采取什么措施去保证系统的稳定性？

## 1.1 限流策略

通过合法性限流、负载限流等措施层层限流，逐层降低访问的流量，可以达到限流的目的。

### 1.1.1 合法性限流

合法性限流是指：仅仅运行将那些合法的用户请行抵达秒杀服务器，而将一些非法的请求全部进行拦截掉。

合法性限流的主要措施有：
```
输入验证码验证，延迟进入时间；
IP检测，非法用户拉入黑名单；
活动开始之前，隐藏活动入口。
```

#### （1）验证码限制

在请求之前，需要知道哪些请求是合法的，比如：爬虫机器人、刷单用户等就是非合法的请求，这需要根据具体情况具体分析。比如，对于机器人，可以使用验证码，这样从输入验证码到下单的过程，可以过滤掉一部分访问量，还可以延迟访问，可以降低流量峰值。

#### （2）IP限制

可以通过技术检测参与用户的IP，如果某个IP的下单频率在毫秒级别或者反复购买同一件商品，可以认定这个IP可能是机器人或者不合法用户在刷单，这样的话可以把这个IP加入到黑名单之中，从而减少不合法的流量。

#### （3）隐藏秒杀活动入口

在秒杀活动开始之前，服务器并不会向外界暴露活动服务的地址，当秒杀活动开始之后才开放地址，比如活动开始之前将下单按钮置灰，在开始时对每个用户加一个1秒之内的随机延迟时间。

### 1.1.2 负载限流

主要的技术有：集群、网络七层模型。

#### （1）Nginx负载限流

常用的工具有Nginx、LVS等。

如果活动开始之前有100万请求，通过合法性限流后有60万，Nginx集群有三台服务器，那么每台服务器也就只需要承载20万的请求量，这样降低一部分请求量。

#### （2）网络七层模型负载

但是，根据网络七层模型（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），Nginx处于第七层。
在网络七层模型之中的其他各层，也可以进行负载，比如说，在第二层的数据链路层，可以通过MAC地址进行负载，如生成一个虚拟MAC，将这个MAC地址映射到其他三个真实的服务器上。同样，也可以在网络第三层通过IP进行负载，在第四层通过端口号进行负载等。

网络七层模型及各层的作用：
```
（1）物理层：物理特性
（2）数据链路层：提供介质访问和链路管理
（3）网络层：IP选址及路由选择
（4）传输层：建立、管理和维护端到端的连接
（5）会话层：建立、管理和维护会话
（6）表示层：数据格式转化、数据加密
（7）应用层：为应用程序提供服务
```


#### （3）级联负载

假设请求到来时，分别在网络七层模型的第二次进行MAC负载 -> 在第三层进行IP负载 -> 第四层进行端口号负载 -> 第七层进行Nginx应用级负载，这样的每一层都会降级一部分流量峰值。这种做法虽然在技术上可以实现，但是也相应地增加了请求的路径。因为每增加一次负载，就会增加一次转发路径，这样可能带来网络延迟问题，因此太多的级联负载也是不推荐的。

对于级联负载，常见的做法：
```
使用Nginx和LVS实现二级负载，这种方式可以满足大部分场景。
```
其中，LVS在七层网络模型中，处于第四层，它是通过网络端口进行的负载，而Nginx处于第七层是应用级别的负载，这里所说的负载都是通过程序的方式实现的软负载（软件负载）。

#### （4）硬件负载

通过购买硬件也可以实现负载，常见的硬负载工具有F5或Array等。

### 1.1.3 服务限流

前两种，通过合法性限流和负载限流的方式，都是在请求到达服务器之前进行限流，如果请求已经到达服务器，又该如何限流呢？这就需要用到服务限流措施。

#### （1）通过web服务器本身限流

通过web服务器本身进行限流，比如Tomcat是一款常用的web服务器，如果连接Tomcat的数量太多，就可能造成Tomcat的服务不稳定。可以把Tomcat最大连接数设置为也合理的值，比如可以设置单Tomcat的最大连接数不超过300，那么当连接数超过300后，就会被Tomcat拒绝，这样可以保证Tomcat的稳定性。

#### （2）通过算法限流

还可以在程序内部，通过一些算法进行限流，比如令牌通算法、漏桶算法。

比如，Google Guava类库中，封装的有限流API。

```java
public class RateLimiter {
    // 令牌通限流：每秒只生成100个令牌，只有抢到令牌的线程才能抢购
    static RateLimiter tokenRateLimiter = RateLimiter.create(100.0);
    public static void miaoShaController() {
        // 每次抢购操作，都会持续尝试1秒
        if(tokenRateLimiter.tryAcquire(1, TimeUnit.SECONDS)) {
            //开启抢购线程
            ......
        }
    }
}
```

#### （3）使用消息队列限流

消息队列，本质上相当于一个缓冲区。假设有10万个请求，一个系统有A B C三个子系统，能承受的流量分别是2W、3W、5W。平均每个服务器会分配3.3W的压力，那么这些流量对于A和B子系统是无法承受得住的，有可能造成其崩溃。这时，可以使用消息队列，请求过来先存在队列中，各个子系统再根据自己的承载能力去主动拉取自己承载数量之内的请求即可，这样对服务器会起到很好的保护。

#### （4）缓存限流

限流的本质，就是为了不断地消减请求的数量，而缓存的作用是为了减少用户请求服务端的数量，缓存也可以限流的一种实现方案。

在限流之前，先将系统设计成前后端分离或者动静分离的结构，然后分别对静态以及动资源态进行缓存限流。

a.静态缓存

对静态请求进行限流时，当客户端第一次请求服务端的时候，服务端会将网页的基本结构代码显示给客户端，比如第一次访问某个网站时，网站服务器就会将搭建此网站的HTML、JavaScript脚本等代码显示给客户端，那么客户端就可以将这些HTML和JavaScript代码缓存到客户端浏览器中，当用户再次访问该网站时，就会从本地浏览器的缓存中获取到HTML和JavaScript代码。

一般地，对HTML这种体积较小的代码会缓存到浏览器中；对于体积较大的图片最好缓存到Nginx中，或者通过Nginx转发到OSS等云服务器中；而对于视频等体积更大的静态资源，可以将它缓存到CDN中，利用CDN区域部署，就近访问的原则来提高用户的访问速度。


b.动态缓存（本地+远程集群）

对于动态缓存，一般先缓存到本地的服务器之中，如果本地服务器缓存失效，再缓存到由Redis组成的远程集群中，进行二次查询，即可以通过搭建由本地缓存（如Guava Cache）以及远程缓存（如Redis集群）组成的二级结构进行动态请求的缓存。

注意：并不是缓存级别越多越好，因为多级缓存中会存在一致性问题，并且缓存级别越多，其一致性问题越严重，而解决这些问题又会带来额外的开发成本和系统开销。


对于大部分项目而言，使用静态缓存加上二级动态缓存已经足够。

### 1.1.4 监控限流

比如，可以通过建立一个线程，专门监控CPU的使用情况，如果其使用率达到某个阈值，就可以临时性地采取服务降级或拒绝策略；过一段时间，CPU等资源利用率恢复正常状态后，之后就可以重新接收并处理新的请求。